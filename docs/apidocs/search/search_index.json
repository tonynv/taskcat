{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is TaskCat? TaskCat is a tool that tests AWS CloudFormation templates. It deploys your AWS CloudFormation template in multiple AWS Regions and generates a report with a pass/fail grade for each region. You can specify the regions and number of Availability Zones you want to include in the test, and pass in parameter values from your AWS CloudFormation template. TaskCat is implemented as a Python class that you import, instantiate, and run. TaskCat was developed by the aws-ia team to test AWS CloudFormation templates that automatically deploy workloads on AWS. We\u2019re pleased to make the tool available to all developers who want to validate their custom AWS CloudFormation templates across AWS Regions See TaskCat documentation . Support GitHub PyPi","title":"Home"},{"location":"#what-is-taskcat","text":"TaskCat is a tool that tests AWS CloudFormation templates. It deploys your AWS CloudFormation template in multiple AWS Regions and generates a report with a pass/fail grade for each region. You can specify the regions and number of Availability Zones you want to include in the test, and pass in parameter values from your AWS CloudFormation template. TaskCat is implemented as a Python class that you import, instantiate, and run. TaskCat was developed by the aws-ia team to test AWS CloudFormation templates that automatically deploy workloads on AWS. We\u2019re pleased to make the tool available to all developers who want to validate their custom AWS CloudFormation templates across AWS Regions See TaskCat documentation .","title":"What is TaskCat?"},{"location":"#support","text":"","title":"Support"},{"location":"#github","text":"","title":"GitHub"},{"location":"#pypi","text":"","title":"PyPi"},{"location":"docs/","text":"What is taskcat? taskcat is a tool that tests AWS CloudFormation templates. It deploys your AWS CloudFormation template in multiple AWS Regions and generates a report with a pass/fail grade for each region. You can specify the regions and number of Availability Zones you want to include in the test, and pass in parameter values from your AWS CloudFormation template. taskcat is implemented as a Python class that you import, instantiate, and run. taskcat was developed by the aws-ia team to test AWS CloudFormation templates that automatically deploy workloads on AWS. We\u2019re pleased to make the tool available to all developers who want to validate their custom AWS CloudFormation templates across AWS Regions Support GitHub PyPi","title":"Index"},{"location":"docs/#what-is-taskcat","text":"taskcat is a tool that tests AWS CloudFormation templates. It deploys your AWS CloudFormation template in multiple AWS Regions and generates a report with a pass/fail grade for each region. You can specify the regions and number of Availability Zones you want to include in the test, and pass in parameter values from your AWS CloudFormation template. taskcat is implemented as a Python class that you import, instantiate, and run. taskcat was developed by the aws-ia team to test AWS CloudFormation templates that automatically deploy workloads on AWS. We\u2019re pleased to make the tool available to all developers who want to validate their custom AWS CloudFormation templates across AWS Regions","title":"What is taskcat?"},{"location":"docs/#support","text":"","title":"Support"},{"location":"docs/#github","text":"","title":"GitHub"},{"location":"docs/#pypi","text":"","title":"PyPi"},{"location":"docs/INSTALLATION/","text":"Installation Currently only installation via pip is supported. Requirements The host taskcat is run on requires access to an AWS account, this can be done by any of the following mechanisms: Environment variables Shared credential file (~/.aws/credentials) AWS config file (~/.aws/config) Assume Role provider Boto2 config file (/etc/boto.cfg and ~/.boto) Instance metadata service on an Amazon EC2 instance that has an IAM role configured. for more info see the boto3 credential configuration documentation . Note docker is only required if building lambda functions using a Dockerfile Installing via pip3 pip3 install taskcat Installing via pip3 --user will install taskcat into homedir, useful if you get permissions errors with the regular method pip3 install taskcat -- user Note The user install dir is platform specific On Mac: ~/Library/Python/3.x/bin/taskcat On Linux: ~/.local/bin Warning Be sure to add the python bin dir to your $PATH Windows Taskcat on Windows is not supported . If you are running Windows 10 we recommend that you install Windows Subsystem for Linux (WSL) and then install taskcat inside the WSL environment. For details, see Install and configure TaskCat on Microsoft Windows 10 .","title":"Installation"},{"location":"docs/INSTALLATION/#installation","text":"Currently only installation via pip is supported.","title":"Installation"},{"location":"docs/INSTALLATION/#requirements","text":"The host taskcat is run on requires access to an AWS account, this can be done by any of the following mechanisms: Environment variables Shared credential file (~/.aws/credentials) AWS config file (~/.aws/config) Assume Role provider Boto2 config file (/etc/boto.cfg and ~/.boto) Instance metadata service on an Amazon EC2 instance that has an IAM role configured. for more info see the boto3 credential configuration documentation . Note docker is only required if building lambda functions using a Dockerfile","title":"Requirements"},{"location":"docs/INSTALLATION/#installing-via-pip3","text":"pip3 install taskcat","title":"Installing via pip3"},{"location":"docs/INSTALLATION/#installing-via-pip3-user","text":"will install taskcat into homedir, useful if you get permissions errors with the regular method pip3 install taskcat -- user Note The user install dir is platform specific On Mac: ~/Library/Python/3.x/bin/taskcat On Linux: ~/.local/bin Warning Be sure to add the python bin dir to your $PATH","title":"Installing via pip3 --user"},{"location":"docs/INSTALLATION/#windows","text":"Taskcat on Windows is not supported . If you are running Windows 10 we recommend that you install Windows Subsystem for Linux (WSL) and then install taskcat inside the WSL environment. For details, see Install and configure TaskCat on Microsoft Windows 10 .","title":"Windows"},{"location":"docs/readme.amiupdater/","text":"AMIUpdater README General Usage. amiupdater <flags> </path/to/template_directory|template_file> For a current list of options, see.. amiupdater -h Leveraging the Upstream Config File Upstream Mappings By default, AMIUpdater uses a config file bundled with taskcat . This config file is populated with common AMI Mappings, such as Amazon Linux AMI and Ubuntu Server 18.04 . To see all of the mappings available, check out the config file To utilize these upstream mappings, simply leverage them in your templates. Note: The AMI IDs are here for example purposes. When first configuring the Mapping, you can filll them with arbitrary data. JSON { (...) \"Mappings\" : { \"AWSAMIRegionMap\" : { \"ap-northeast-1\" : { \"AMZNLINUXHVM\" : \"ami-00a5245b4816c38e6\" , \"CENTOS7HVM\" : \"ami-8e8847f1\" , \"US1404HVM\" : \"ami-0be9269b44d4b26c1\" , \"US1604HVM\" : \"ami-0d5e82481c5fd4ad5\" , \"SLES15HVM\" : \"ami-09161bc9964f46a98\" }, \"ap-northeast-2\" : { \"AMZNLINUXHVM\" : \"ami-00dc207f8ba6dc919\" , \"CENTOS7HVM\" : \"ami-bf9c36d1\" , \"US1404HVM\" : \"ami-017332df4b882edd2\" , \"US1604HVM\" : \"ami-0507b772e2c9b8c15\" , \"SLES15HVM\" : \"ami-04ecb44b7d8e8d354\" }, \"ap-south-1\" : { \"AMZNLINUXHVM\" : \"ami-0ad42f4f66f6c1cc9\" , \"CENTOS7HVM\" : \"ami-1780a878\" , \"US1404HVM\" : \"ami-09dcf5653a185f5df\" , \"US1604HVM\" : \"ami-0c8810f694cbe10ba\" , \"SLES15HVM\" : \"ami-025d8258d76079367\" } (...) } } } } YAML Mappings : AWSAMIRegionMap : ap-northeast-1 : AMZNLINUXHVM : ami-00a5245b4816c38e6, CENTOS7HVM : ami-8e8847f1, US1404HVM : ami-0be9269b44d4b26c1, US1604HVM : ami-0d5e82481c5fd4ad5, SLES15HVM : ami-09161bc9964f46a98 ap-northeast-2 : AMZNLINUXHVM : ami-00dc207f8ba6dc919, CENTOS7HVM : ami-bf9c36d1, US1404HVM : ami-017332df4b882edd2, US1604HVM : ami-0507b772e2c9b8c15, SLES15HVM : ami-04ecb44b7d8e8d354 ap-south-1 : AMZNLINUXHVM : ami-0ad42f4f66f6c1cc9, CENTOS7HVM : ami-1780a878, US1404HVM : ami-09dcf5653a185f5df, US1604HVM : ami-0c8810f694cbe10ba, SLES15HVM : ami-025d8258d76079367 Defining your own AMI Mappings Custom Config File Functionally the same as the upstream config file, a local config file can be created and used in deployment pipelines. For a full list of filters, available, please see the AWS EC2 API Documentation . # Owner-id must be in quotes # Whereas, all other filters do not need quotes, # because they are not in a number format global : AMIs : CUSTOM_MAPPING_1 : name : my_super_awesome_name-* owner-id : 1234567890 CUSTOM_MAPPING_2 : name : my_super_other_awesome_name ???? * owner-id : 1234567890 architecture : arm64 Template Inline Config JSON \"Metadata\" : { \"AWSAMIRegionMap\" :{ \"Filters\" :{ \"<MAPPING_NAME>\" :{ \"name\" : \"my awesome AMI NAME\" , \"owner-id\" : \"01234567890\" } } } YAML Metadata : AWSAMIRegionMap : Filters : <MAPPING_NAME> : name : my awesome AMI NAME owner-id : 01234567890","title":"*AMIUpdater README*"},{"location":"docs/readme.amiupdater/#amiupdater-readme","text":"","title":"AMIUpdater README"},{"location":"docs/readme.amiupdater/#general-usage","text":"amiupdater <flags> </path/to/template_directory|template_file> For a current list of options, see.. amiupdater -h","title":"General Usage."},{"location":"docs/readme.amiupdater/#leveraging-the-upstream-config-file","text":"","title":"Leveraging the Upstream Config File"},{"location":"docs/readme.amiupdater/#upstream-mappings","text":"By default, AMIUpdater uses a config file bundled with taskcat . This config file is populated with common AMI Mappings, such as Amazon Linux AMI and Ubuntu Server 18.04 . To see all of the mappings available, check out the config file To utilize these upstream mappings, simply leverage them in your templates. Note: The AMI IDs are here for example purposes. When first configuring the Mapping, you can filll them with arbitrary data. JSON { (...) \"Mappings\" : { \"AWSAMIRegionMap\" : { \"ap-northeast-1\" : { \"AMZNLINUXHVM\" : \"ami-00a5245b4816c38e6\" , \"CENTOS7HVM\" : \"ami-8e8847f1\" , \"US1404HVM\" : \"ami-0be9269b44d4b26c1\" , \"US1604HVM\" : \"ami-0d5e82481c5fd4ad5\" , \"SLES15HVM\" : \"ami-09161bc9964f46a98\" }, \"ap-northeast-2\" : { \"AMZNLINUXHVM\" : \"ami-00dc207f8ba6dc919\" , \"CENTOS7HVM\" : \"ami-bf9c36d1\" , \"US1404HVM\" : \"ami-017332df4b882edd2\" , \"US1604HVM\" : \"ami-0507b772e2c9b8c15\" , \"SLES15HVM\" : \"ami-04ecb44b7d8e8d354\" }, \"ap-south-1\" : { \"AMZNLINUXHVM\" : \"ami-0ad42f4f66f6c1cc9\" , \"CENTOS7HVM\" : \"ami-1780a878\" , \"US1404HVM\" : \"ami-09dcf5653a185f5df\" , \"US1604HVM\" : \"ami-0c8810f694cbe10ba\" , \"SLES15HVM\" : \"ami-025d8258d76079367\" } (...) } } } } YAML Mappings : AWSAMIRegionMap : ap-northeast-1 : AMZNLINUXHVM : ami-00a5245b4816c38e6, CENTOS7HVM : ami-8e8847f1, US1404HVM : ami-0be9269b44d4b26c1, US1604HVM : ami-0d5e82481c5fd4ad5, SLES15HVM : ami-09161bc9964f46a98 ap-northeast-2 : AMZNLINUXHVM : ami-00dc207f8ba6dc919, CENTOS7HVM : ami-bf9c36d1, US1404HVM : ami-017332df4b882edd2, US1604HVM : ami-0507b772e2c9b8c15, SLES15HVM : ami-04ecb44b7d8e8d354 ap-south-1 : AMZNLINUXHVM : ami-0ad42f4f66f6c1cc9, CENTOS7HVM : ami-1780a878, US1404HVM : ami-09dcf5653a185f5df, US1604HVM : ami-0c8810f694cbe10ba, SLES15HVM : ami-025d8258d76079367","title":"Upstream Mappings"},{"location":"docs/readme.amiupdater/#defining-your-own-ami-mappings","text":"","title":"Defining your own AMI Mappings"},{"location":"docs/readme.amiupdater/#custom-config-file","text":"Functionally the same as the upstream config file, a local config file can be created and used in deployment pipelines. For a full list of filters, available, please see the AWS EC2 API Documentation . # Owner-id must be in quotes # Whereas, all other filters do not need quotes, # because they are not in a number format global : AMIs : CUSTOM_MAPPING_1 : name : my_super_awesome_name-* owner-id : 1234567890 CUSTOM_MAPPING_2 : name : my_super_other_awesome_name ???? * owner-id : 1234567890 architecture : arm64","title":"Custom Config File"},{"location":"docs/readme.amiupdater/#template-inline-config","text":"JSON \"Metadata\" : { \"AWSAMIRegionMap\" :{ \"Filters\" :{ \"<MAPPING_NAME>\" :{ \"name\" : \"my awesome AMI NAME\" , \"owner-id\" : \"01234567890\" } } } YAML Metadata : AWSAMIRegionMap : Filters : <MAPPING_NAME> : name : my awesome AMI NAME owner-id : 01234567890","title":"Template Inline Config"},{"location":"docs/administrative/CODE_OF_CONDUCT/","text":"Code of Conduct 1. Purpose A primary goal of TaskCat is to be inclusive to the largest number of contributors, with the most varied and diverse backgrounds possible. As such, we are committed to providing a friendly, safe and welcoming environment for all, regardless of gender, sexual orientation, ability, ethnicity, socioeconomic status, and religion (or lack thereof). This code of conduct outlines our expectations for all those who participate in our community, as well as the consequences for unacceptable behavior. We invite all those who participate in TaskCat to help us create safe and positive experiences for everyone. 2. Open Source Citizenship A supplemental goal of this Code of Conduct is to increase open source citizenship by encouraging participants to recognize and strengthen the relationships between our actions and their effects on our community. Communities mirror the societies in which they exist and positive action is essential to counteract the many forms of inequality and abuses of power that exist in society. If you see someone who is making an extra effort to ensure our community is welcoming, friendly, and encourages all participants to contribute to the fullest extent, we want to know. 3. Expected Behavior The following behaviors are expected and requested of all community members: Participate in an authentic and active way. In doing so, you contribute to the health and longevity of this community. Exercise consideration and respect in your speech and actions. Attempt collaboration before conflict. Refrain from demeaning, discriminatory, or harassing behavior and speech. Be mindful of your surroundings and of your fellow participants. Alert community leaders if you notice a dangerous situation, someone in distress, or violations of this Code of Conduct, even if they seem inconsequential. Remember that community event venues may be shared with members of the public; please be respectful to all patrons of these locations. 4. Unacceptable Behavior The following behaviors are considered harassment and are unacceptable within our community: Violence, threats of violence or violent language directed against another person. Sexist, racist, homophobic, transphobic, ableist or otherwise discriminatory jokes and language. Posting or displaying sexually explicit or violent material. Posting or threatening to post other people\u2019s personally identifying information (\"doxing\"). Personal insults, particularly those related to gender, sexual orientation, race, religion, or disability. Inappropriate photography or recording. Inappropriate physical contact. You should have someone\u2019s consent before touching them. Unwelcome sexual attention. This includes, sexualized comments or jokes; inappropriate touching, groping, and unwelcomed sexual advances. Deliberate intimidation, stalking or following (online or in person). Advocating for, or encouraging, any of the above behavior. Sustained disruption of community events, including talks and presentations. 5. Consequences of Unacceptable Behavior Unacceptable behavior from any community member, including sponsors and those with decision-making authority, will not be tolerated. Anyone asked to stop unacceptable behavior is expected to comply immediately. If a community member engages in unacceptable behavior, the community organizers may take any action they deem appropriate, up to and including a temporary ban or permanent expulsion from the community without warning (and without refund in the case of a paid event). 6. Reporting Guidelines If you are subject to or witness unacceptable behavior, or have any other concerns, please notify a community organizer as soon as possible. quickstart@amazon.com. Link to reporting guidelines: codeofconduct@amazon.com Additionally, community organizers are available to help community members engage with local law enforcement or to otherwise help those experiencing unacceptable behavior feel safe. In the context of in-person events, organizers will also provide escorts as desired by the person experiencing distress. 7. Addressing Grievances If you feel you have been falsely or unfairly accused of violating this Code of Conduct, you should notify AWS Quickstart with a concise description of your grievance. Your grievance will be handled in accordance with our existing governing policies. Policy 8. Scope We expect all community participants (contributors, paid or otherwise; sponsors; and other guests) to abide by this Code of Conduct in all community venues\u2013online and in-person\u2013as well as in all one-on-one communications pertaining to community business. This code of conduct and its related procedures also applies to unacceptable behavior occurring outside the scope of community activities when such behavior has the potential to adversely affect the safety and well-being of community members. 9. Contact info quickstart@amazon.com 10. License and attribution This Code of Conduct is distributed under a Creative Commons Attribution-ShareAlike license . Portions of text derived from the Django Code of Conduct and the Geek Feminism Anti-Harassment Policy . Retrieved on November 22, 2016 from http://citizencodeofconduct.org/","title":"Code of Conduct"},{"location":"docs/administrative/CODE_OF_CONDUCT/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"docs/administrative/CODE_OF_CONDUCT/#1-purpose","text":"A primary goal of TaskCat is to be inclusive to the largest number of contributors, with the most varied and diverse backgrounds possible. As such, we are committed to providing a friendly, safe and welcoming environment for all, regardless of gender, sexual orientation, ability, ethnicity, socioeconomic status, and religion (or lack thereof). This code of conduct outlines our expectations for all those who participate in our community, as well as the consequences for unacceptable behavior. We invite all those who participate in TaskCat to help us create safe and positive experiences for everyone.","title":"1. Purpose"},{"location":"docs/administrative/CODE_OF_CONDUCT/#2-open-source-citizenship","text":"A supplemental goal of this Code of Conduct is to increase open source citizenship by encouraging participants to recognize and strengthen the relationships between our actions and their effects on our community. Communities mirror the societies in which they exist and positive action is essential to counteract the many forms of inequality and abuses of power that exist in society. If you see someone who is making an extra effort to ensure our community is welcoming, friendly, and encourages all participants to contribute to the fullest extent, we want to know.","title":"2. Open Source Citizenship"},{"location":"docs/administrative/CODE_OF_CONDUCT/#3-expected-behavior","text":"The following behaviors are expected and requested of all community members: Participate in an authentic and active way. In doing so, you contribute to the health and longevity of this community. Exercise consideration and respect in your speech and actions. Attempt collaboration before conflict. Refrain from demeaning, discriminatory, or harassing behavior and speech. Be mindful of your surroundings and of your fellow participants. Alert community leaders if you notice a dangerous situation, someone in distress, or violations of this Code of Conduct, even if they seem inconsequential. Remember that community event venues may be shared with members of the public; please be respectful to all patrons of these locations.","title":"3. Expected Behavior"},{"location":"docs/administrative/CODE_OF_CONDUCT/#4-unacceptable-behavior","text":"The following behaviors are considered harassment and are unacceptable within our community: Violence, threats of violence or violent language directed against another person. Sexist, racist, homophobic, transphobic, ableist or otherwise discriminatory jokes and language. Posting or displaying sexually explicit or violent material. Posting or threatening to post other people\u2019s personally identifying information (\"doxing\"). Personal insults, particularly those related to gender, sexual orientation, race, religion, or disability. Inappropriate photography or recording. Inappropriate physical contact. You should have someone\u2019s consent before touching them. Unwelcome sexual attention. This includes, sexualized comments or jokes; inappropriate touching, groping, and unwelcomed sexual advances. Deliberate intimidation, stalking or following (online or in person). Advocating for, or encouraging, any of the above behavior. Sustained disruption of community events, including talks and presentations.","title":"4. Unacceptable Behavior"},{"location":"docs/administrative/CODE_OF_CONDUCT/#5-consequences-of-unacceptable-behavior","text":"Unacceptable behavior from any community member, including sponsors and those with decision-making authority, will not be tolerated. Anyone asked to stop unacceptable behavior is expected to comply immediately. If a community member engages in unacceptable behavior, the community organizers may take any action they deem appropriate, up to and including a temporary ban or permanent expulsion from the community without warning (and without refund in the case of a paid event).","title":"5. Consequences of Unacceptable Behavior"},{"location":"docs/administrative/CODE_OF_CONDUCT/#6-reporting-guidelines","text":"If you are subject to or witness unacceptable behavior, or have any other concerns, please notify a community organizer as soon as possible. quickstart@amazon.com. Link to reporting guidelines: codeofconduct@amazon.com Additionally, community organizers are available to help community members engage with local law enforcement or to otherwise help those experiencing unacceptable behavior feel safe. In the context of in-person events, organizers will also provide escorts as desired by the person experiencing distress.","title":"6. Reporting Guidelines"},{"location":"docs/administrative/CODE_OF_CONDUCT/#7-addressing-grievances","text":"If you feel you have been falsely or unfairly accused of violating this Code of Conduct, you should notify AWS Quickstart with a concise description of your grievance. Your grievance will be handled in accordance with our existing governing policies. Policy","title":"7. Addressing Grievances"},{"location":"docs/administrative/CODE_OF_CONDUCT/#8-scope","text":"We expect all community participants (contributors, paid or otherwise; sponsors; and other guests) to abide by this Code of Conduct in all community venues\u2013online and in-person\u2013as well as in all one-on-one communications pertaining to community business. This code of conduct and its related procedures also applies to unacceptable behavior occurring outside the scope of community activities when such behavior has the potential to adversely affect the safety and well-being of community members.","title":"8. Scope"},{"location":"docs/administrative/CODE_OF_CONDUCT/#9-contact-info","text":"quickstart@amazon.com","title":"9. Contact info"},{"location":"docs/administrative/CODE_OF_CONDUCT/#10-license-and-attribution","text":"This Code of Conduct is distributed under a Creative Commons Attribution-ShareAlike license . Portions of text derived from the Django Code of Conduct and the Geek Feminism Anti-Harassment Policy . Retrieved on November 22, 2016 from http://citizencodeofconduct.org/","title":"10. License and attribution"},{"location":"docs/administrative/CONTRIBUTING/","text":"Contributing Guidelines Thank you for your interest in contributing to our project. Whether it's a bug report, new feature, correction, or additional documentation, we greatly value feedback and contributions from our community. Please read through this document before submitting any issues or pull requests to ensure we have all the necessary information to effectively respond to your bug report or contribution. Documentation Links: Module Documentation User Guide Reporting Bugs/Feature Requests We welcome you to use the GitHub issue tracker to report bugs or suggest features. When filing an issue, please check existing open , or recently closed , issues to make sure somebody else hasn't already reported the issue. Please try to include as much information as you can. Details like these are incredibly useful: A reproducible test case or series of steps The version of our code being used Any modifications you've made relevant to the bug Anything unusual about your environment or deployment Contributing via Pull Requests (Pull request template provided) Contributions via pull requests are much appreciated. Before sending us a pull request, please ensure that: All changes are staged into the develop branch (Send PR to the develop branch) You check existing open, and recently merged, pull requests to make sure someone else hasn't addressed the problem already. You open an issue to discuss any significant work - we would hate for your time to be wasted. To send us a pull request, please: Fork the repository. Modify the source; please focus on the specific change you are contributing. If you also reformat all the code, it will be hard for us to focus on your change. Ensure local tests pass. Commit to your fork using clear commit messages. Send us a pull request, answering any default questions in the pull request interface. Pay attention to any automated CI failures reported in the pull request, and stay involved in the conversation. GitHub provides additional document on forking a repository and creating a pull request . Licensing We may ask you to affirm the Apache 2.0 agreement for larger changes.","title":"Contributing"},{"location":"docs/administrative/CONTRIBUTING/#contributing-guidelines","text":"Thank you for your interest in contributing to our project. Whether it's a bug report, new feature, correction, or additional documentation, we greatly value feedback and contributions from our community. Please read through this document before submitting any issues or pull requests to ensure we have all the necessary information to effectively respond to your bug report or contribution. Documentation Links: Module Documentation User Guide","title":"Contributing Guidelines"},{"location":"docs/administrative/CONTRIBUTING/#reporting-bugsfeature-requests","text":"We welcome you to use the GitHub issue tracker to report bugs or suggest features. When filing an issue, please check existing open , or recently closed , issues to make sure somebody else hasn't already reported the issue. Please try to include as much information as you can. Details like these are incredibly useful: A reproducible test case or series of steps The version of our code being used Any modifications you've made relevant to the bug Anything unusual about your environment or deployment","title":"Reporting Bugs/Feature Requests"},{"location":"docs/administrative/CONTRIBUTING/#contributing-via-pull-requests-pull-request-template-provided","text":"Contributions via pull requests are much appreciated. Before sending us a pull request, please ensure that: All changes are staged into the develop branch (Send PR to the develop branch) You check existing open, and recently merged, pull requests to make sure someone else hasn't addressed the problem already. You open an issue to discuss any significant work - we would hate for your time to be wasted. To send us a pull request, please: Fork the repository. Modify the source; please focus on the specific change you are contributing. If you also reformat all the code, it will be hard for us to focus on your change. Ensure local tests pass. Commit to your fork using clear commit messages. Send us a pull request, answering any default questions in the pull request interface. Pay attention to any automated CI failures reported in the pull request, and stay involved in the conversation. GitHub provides additional document on forking a repository and creating a pull request .","title":"Contributing via Pull Requests (Pull request template provided)"},{"location":"docs/administrative/CONTRIBUTING/#licensing","text":"We may ask you to affirm the Apache 2.0 agreement for larger changes.","title":"Licensing"},{"location":"docs/schema/taskcat_schema/","text":"Schema Docs Expand all Collapse all Type: object Taskcat configuration file No Additional Properties general root general Type: object Default: {\"artifact_regions\": null, \"auth\": null, \"parameters\": null, \"posthooks\": null, \"prehooks\": null, \"regions\": null, \"s3_bucket\": null, \"s3_regional_buckets\": null, \"tags\": null} General configuration settings. No Additional Properties artifact_regions root general artifact_regions Type: array of string List of AWS regions where artifacts need to be copied. This helps same region artifact bucket access to resources Each item of this array must be: root general artifact_regions artifact_regions items Type: string AWS Region name Must match regular expression: ^(ap|eu|us|sa|ca|cn|af|me|us-gov)-(central|south|north|east|west|southeast|southwest|northeast|northwest)-[0-9]$ Example: \"us-east-1\" auth root general auth Type: object AWS authentication section Example: { \"cn-northwest-1\" : \"china-profile\" , \"default\" : \"my-default-profile\" , \"us-east-2\" : \"specific-profile-for-us-east-2\" } Additional Properties Each additional property must conform to the following schema root general auth additionalProperties Type: string parameters root general parameters Type: object Parameter key-values to pass to CloudFormation, parameters provided in global config take precedence Additional Properties Each additional property must conform to the following schema root general parameters additionalProperties Any of Option 1 Option 2 Option 3 Option 4 root general parameters additionalProperties anyOf item 0 Type: array Each item of this array must be: root general parameters additionalProperties anyOf item 0 item 0 items Any of Option 1 Option 2 root general parameters additionalProperties anyOf item 0 item 0 items anyOf item 0 Type: integer root general parameters additionalProperties anyOf item 0 item 0 items anyOf item 1 Type: string root general parameters additionalProperties anyOf item 1 Type: boolean root general parameters additionalProperties anyOf item 2 Type: integer root general parameters additionalProperties anyOf item 3 Type: string posthooks root general posthooks Type: array hooks to execute after executing tests Each item of this array must be: root general posthooks HookData Type: object Hook definition No Additional Properties config root general posthooks posthooks items config Type: object hook configuration type root general posthooks posthooks items type Type: string hook type prehooks root general prehooks Type: array hooks to execute prior to executing tests Each item of this array must be: root general prehooks HookData Type: object Hook definition Same definition as general_posthooks_items regions root general regions Type: array of string List of AWS regions Each item of this array must be: root general regions regions items Type: string AWS Region name Must match regular expression: ^(ap|eu|us|sa|ca|cn|af|me|us-gov)-(central|south|north|east|west|southeast|southwest|northeast|northwest)-[0-9]$ Example: \"us-east-1\" s3_bucket root general s3_bucket Type: string Name of S3 bucket to upload project to, if left out a bucket will be auto-generated Example: \"my-s3-bucket-name\" s3_regional_buckets root general s3_regional_buckets Type: boolean Enable regional auto-buckets. Examples: true false tags root general tags Type: object Tags to apply to CloudFormation template Example: { \"CostCenter\" : \"1001\" } Additional Properties Each additional property must conform to the following schema root general tags additionalProperties Type: string project root project Type: object Default: {\"artifact_regions\": null, \"auth\": null, \"az_blacklist\": null, \"build_submodules\": null, \"lambda_source_path\": null, \"lambda_zip_path\": null, \"name\": null, \"org_id\": null, \"owner\": null, \"package_lambda\": null, \"parameters\": null, \"posthooks\": null, \"prehooks\": null, \"regions\": null, \"role_name\": null, \"s3_bucket\": null, \"s3_enable_sig_v2\": null, \"s3_object_acl\": null, \"s3_regional_buckets\": null, \"shorten_stack_name\": null, \"tags\": null, \"template\": null} Project specific configuration section No Additional Properties artifact_regions root project artifact_regions Type: array of string List of AWS regions where artifacts need to be copied. This helps same region artifact bucket access to resources Each item of this array must be: root project artifact_regions artifact_regions items Type: string AWS Region name Must match regular expression: ^(ap|eu|us|sa|ca|cn|af|me|us-gov)-(central|south|north|east|west|southeast|southwest|northeast|northwest)-[0-9]$ Example: \"us-east-1\" auth root project auth Type: object AWS authentication section Example: { \"cn-northwest-1\" : \"china-profile\" , \"default\" : \"my-default-profile\" , \"us-east-2\" : \"specific-profile-for-us-east-2\" } Additional Properties Each additional property must conform to the following schema root project auth additionalProperties Type: string az_blacklist root project az_blacklist Type: array of string List of Availablilty Zones ID's to exclude when generating availability zones Each item of this array must be: root project az_blacklist az_blacklist items Type: string Availability Zone ID, eg.: 'use1-az1' Must match regular expression: (afs1-az1|afs1-az2|afs1-az3|ape1-az1|ape1-az2|ape1-az3|apne1-az1|apne1-az2|apne1-az4|apne2-az1|apne2-az2|apne2-az3|apne2-az4|apne3-az1|apne3-az2|apne3-az3|aps1-az1|aps1-az2|aps1-az3|apse1-az1|apse1-az2|apse1-az3|apse2-az1|apse2-az2|apse2-az3|apse3-az1|apse3-az2|apse3-az3|cac1-az1|cac1-az2|cac1-az4|euc1-az1|euc1-az2|euc1-az3|eun1-az1|eun1-az2|eun1-az3|eus1-az1|eus1-az2|eus1-az3|euw1-az1|euw1-az2|euw1-az3|euw2-az1|euw2-az2|euw2-az3|euw3-az1|euw3-az2|euw3-az3|mes1-az1|mes1-az2|mes1-az3|sae1-az1|sae1-az2|sae1-az3|use1-atl1-az1|use1-az1|use1-az2|use1-az3|use1-az4|use1-az5|use1-az6|use1-bos1-az1|use1-chi1-az1|use1-dfw1-az1|use1-iah1-az1|use1-mci1-az1|use1-mia1-az1|use1-msp1-az1|use1-nyc1-az1|use1-phl1-az1|use2-az1|use2-az2|use2-az3|usw1-az1|usw1-az3|usw2-az1|usw2-az2|usw2-az3|usw2-az4|usw2-den1-az1|usw2-las1-az1|usw2-lax1-az1|usw2-lax1-az2|usw2-pdx1-az1|usw2-phx1-az1|usw2-sea1-az1) Examples: \"usw2-laz1-az1\" \"use2-az2\" build_submodules root project build_submodules Type: boolean Build Lambda zips recursively for submodules, set to false to disable Examples: true false lambda_source_path root project lambda_source_path Type: string Path relative to the project root containing Lambda zip files, default is 'lambda_functions/source' Example: \"functions/source\" lambda_zip_path root project lambda_zip_path Type: string Path relative to the project root to place Lambda zip files Example: \"functions/packages\" name root project name Type: string Project name, used as s3 key prefix when uploading objects Must match regular expression: ^[a-z0-9-/]*$ Example: \"my-project-name\" org_id root project org_id Type: string Organization ID to use when launching CFN Stacks. starts with o-. It is found on Organization Settings page owner root project owner Type: string email address for project owner (not used at present) Example: \"Bob.Slydell@example.com\" package_lambda root project package_lambda Type: boolean Package Lambda functions into zips before uploading to s3, set to false to disable Examples: true false parameters root project parameters Type: object Parameter key-values to pass to CloudFormation, parameters provided in global config take precedence Additional Properties Each additional property must conform to the following schema root project parameters additionalProperties Any of Option 1 Option 2 Option 3 Option 4 root project parameters additionalProperties anyOf item 0 Type: array Each item of this array must be: root project parameters additionalProperties anyOf item 0 item 0 items Any of Option 1 Option 2 root project parameters additionalProperties anyOf item 0 item 0 items anyOf item 0 Type: integer root project parameters additionalProperties anyOf item 0 item 0 items anyOf item 1 Type: string root project parameters additionalProperties anyOf item 1 Type: boolean root project parameters additionalProperties anyOf item 2 Type: integer root project parameters additionalProperties anyOf item 3 Type: string posthooks root project posthooks Type: array hooks to execute after executing tests Each item of this array must be: root project posthooks HookData Type: object Hook definition Same definition as general_posthooks_items prehooks root project prehooks Type: array hooks to execute prior to executing tests Each item of this array must be: root project prehooks HookData Type: object Hook definition Same definition as general_posthooks_items regions root project regions Type: array of string List of AWS regions Each item of this array must be: root project regions regions items Type: string AWS Region name Must match regular expression: ^(ap|eu|us|sa|ca|cn|af|me|us-gov)-(central|south|north|east|west|southeast|southwest|northeast|northwest)-[0-9]$ Example: \"us-east-1\" role_name root project role_name Type: string Role name to use when launching CFN Stacks. s3_bucket root project s3_bucket Type: string Name of S3 bucket to upload project to, if left out a bucket will be auto-generated Must match regular expression: ^[a-z0-9-]*$ Example: \"my-s3-bucket-name\" s3_enable_sig_v2 root project s3_enable_sig_v2 Type: boolean Enable (deprecated) sigv2 access to auto-generated buckets Examples: true false s3_object_acl root project s3_object_acl Type: string Default: \"private\" ACL for uploaded s3 objects Must match regular expression: ^(bucket-owner-full-control|bucket-owner-read|authenticated-read|aws-exec-read|public-read-write|public-read|private)$ Examples: \"bucket-owner-read\" \"private\" s3_regional_buckets root project s3_regional_buckets Type: boolean Enable regional auto-buckets. Examples: true false shorten_stack_name root project shorten_stack_name Type: boolean Shorten stack names generated for tests, set to true to enable Examples: true false tags root project tags Type: object Tags to apply to CloudFormation template Example: { \"CostCenter\" : \"1001\" } Additional Properties Each additional property must conform to the following schema root project tags additionalProperties Type: string template root project template Type: string path to template file relative to the project config file path Example: \"cloudformation_templates/\" tests root tests Type: object Default: {} Additional Properties Each additional property must conform to the following schema root tests TestConfig Type: object Test specific configuration section. No Additional Properties artifact_regions root tests additionalProperties artifact_regions Type: array of string List of AWS regions where artifacts need to be copied. This helps same region artifact bucket access to resources Each item of this array must be: root tests additionalProperties artifact_regions artifact_regions items Type: string AWS Region name Must match regular expression: ^(ap|eu|us|sa|ca|cn|af|me|us-gov)-(central|south|north|east|west|southeast|southwest|northeast|northwest)-[0-9]$ Example: \"us-east-1\" auth root tests additionalProperties auth Type: object AWS authentication section Example: { \"cn-northwest-1\" : \"china-profile\" , \"default\" : \"my-default-profile\" , \"us-east-2\" : \"specific-profile-for-us-east-2\" } Additional Properties Each additional property must conform to the following schema root tests additionalProperties auth additionalProperties Type: string az_blacklist root tests additionalProperties az_blacklist Type: array of string List of Availablilty Zones ID's to exclude when generating availability zones Each item of this array must be: root tests additionalProperties az_blacklist az_blacklist items Type: string Availability Zone ID, eg.: 'use1-az1' Must match regular expression: (afs1-az1|afs1-az2|afs1-az3|ape1-az1|ape1-az2|ape1-az3|apne1-az1|apne1-az2|apne1-az4|apne2-az1|apne2-az2|apne2-az3|apne2-az4|apne3-az1|apne3-az2|apne3-az3|aps1-az1|aps1-az2|aps1-az3|apse1-az1|apse1-az2|apse1-az3|apse2-az1|apse2-az2|apse2-az3|apse3-az1|apse3-az2|apse3-az3|cac1-az1|cac1-az2|cac1-az4|euc1-az1|euc1-az2|euc1-az3|eun1-az1|eun1-az2|eun1-az3|eus1-az1|eus1-az2|eus1-az3|euw1-az1|euw1-az2|euw1-az3|euw2-az1|euw2-az2|euw2-az3|euw3-az1|euw3-az2|euw3-az3|mes1-az1|mes1-az2|mes1-az3|sae1-az1|sae1-az2|sae1-az3|use1-atl1-az1|use1-az1|use1-az2|use1-az3|use1-az4|use1-az5|use1-az6|use1-bos1-az1|use1-chi1-az1|use1-dfw1-az1|use1-iah1-az1|use1-mci1-az1|use1-mia1-az1|use1-msp1-az1|use1-nyc1-az1|use1-phl1-az1|use2-az1|use2-az2|use2-az3|usw1-az1|usw1-az3|usw2-az1|usw2-az2|usw2-az3|usw2-az4|usw2-den1-az1|usw2-las1-az1|usw2-lax1-az1|usw2-lax1-az2|usw2-pdx1-az1|usw2-phx1-az1|usw2-sea1-az1) Examples: \"usw2-laz1-az1\" \"use2-az2\" parameters root tests additionalProperties parameters Type: object Default: {} Parameter key-values to pass to CloudFormation, parameters provided in global config take precedence Additional Properties Each additional property must conform to the following schema root tests additionalProperties parameters additionalProperties Any of Option 1 Option 2 Option 3 Option 4 root tests additionalProperties parameters additionalProperties anyOf item 0 Type: array Each item of this array must be: root tests additionalProperties parameters additionalProperties anyOf item 0 item 0 items Any of Option 1 Option 2 root tests additionalProperties parameters additionalProperties anyOf item 0 item 0 items anyOf item 0 Type: integer root tests additionalProperties parameters additionalProperties anyOf item 0 item 0 items anyOf item 1 Type: string root tests additionalProperties parameters additionalProperties anyOf item 1 Type: boolean root tests additionalProperties parameters additionalProperties anyOf item 2 Type: integer root tests additionalProperties parameters additionalProperties anyOf item 3 Type: string posthooks root tests additionalProperties posthooks Type: array hooks to execute after executing tests Each item of this array must be: root tests additionalProperties posthooks HookData Type: object Hook definition Same definition as general_posthooks_items prehooks root tests additionalProperties prehooks Type: array hooks to execute prior to executing tests Each item of this array must be: root tests additionalProperties prehooks HookData Type: object Hook definition Same definition as general_posthooks_items regions root tests additionalProperties regions Type: array of string List of AWS regions Each item of this array must be: root tests additionalProperties regions regions items Type: string AWS Region name Must match regular expression: ^(ap|eu|us|sa|ca|cn|af|me|us-gov)-(central|south|north|east|west|southeast|southwest|northeast|northwest)-[0-9]$ Example: \"us-east-1\" role_name root tests additionalProperties role_name Type: string Role name to use when launching CFN Stacks. s3_bucket root tests additionalProperties s3_bucket Type: string Name of S3 bucket to upload project to, if left out a bucket will be auto-generated Must match regular expression: ^[a-z0-9-]*$ Example: \"my-s3-bucket-name\" s3_regional_buckets root tests additionalProperties s3_regional_buckets Type: boolean Enable regional auto-buckets. Examples: true false stack_name root tests additionalProperties stack_name Type: string Cloudformation Stack Name stack_name_prefix root tests additionalProperties stack_name_prefix Type: string Prefix to apply to generated CFN Stack Name stack_name_suffix root tests additionalProperties stack_name_suffix Type: string Suffix to apply to generated CFN Stack Name tags root tests additionalProperties tags Type: object Tags to apply to CloudFormation template Example: { \"CostCenter\" : \"1001\" } Additional Properties Each additional property must conform to the following schema root tests additionalProperties tags additionalProperties Type: string template root tests additionalProperties template Type: string path to template file relative to the project config file path Example: \"cloudformation_templates/\" Generated using json-schema-for-humans on 2022-10-19 at 19:03:43 -0700","title":"Configuration Schema"},{"location":"docs/usage/GENERAL_USAGE/","text":"Usage CLI The cli is self documenting by using --help . The most common use of taskcat is for executing function tests of CloudFormation templates. The command for this is: taskcat test run add --help to see the supported flags and arguments Python Taskcat can be imported into Python and used in the testing framework of your choice. from taskcat.testing import CFNTest test = CFNTest . from_file ( project_root = './template_dir' ) with test as stacks : # Calling 'with' or 'test.run()' will deploy the stacks. for stack in stacks : print ( f \"Testing { stack . name } \" ) bucket_name = \"\" for output in stack . outputs : if output . key == \"LogsBucketName\" : bucket_name = output . value break assert \"logs\" in bucket_name assert stack . region . name in bucket_name print ( f \"Created bucket: { bucket_name } \" ) The example used here is very simple, you would most likely leverage other python modules like boto3 to do more advanced testing. The CFNTest object can be passed the same arguments as taskcat test run . See the docs for more details. Config files taskcat has several configuration files which can be used to set behaviors in a flexible way. Global config ~/.taskcat.yml provides global settings that become defaults for all projects. Please see our schema reference for specific configuration options that are available. Project config <PROJECT_ROOT>/.taskcat.yml provides project specific configuration. Please see our schema reference for specific configuration options that are available. Precedence With the exception of the parameters section, more specific config with the same key takes precedence. The rationale behind having parameters function this way is so that values can be overridden at a system level outside of a project, that is likely committed to source control. parameters that define account specific things like VPC details, Key Pairs, or secrets like API keys can be defined per host outside of source control. For example, consider this global config: ~/.taskcat.yml general : s3_bucket : my-globally-defined-bucket parameters : KeyPair : my-global-ec2-keypair Given a simple project config: project : name : my-project regions : - us-east-2 tests : default : template : ./template.yaml The effective test configuration would become: tests : default : template : ./template.yaml s3_bucket : my-globally-defined-bucket parameters : KeyPair : my-global-ec2-keypair If any item is re-defined in a project it takes precedence over the global value. Anything defined in a test takes precedence over what is defined in the project or global configuration. with the exception of the parameters section which works in reverse. For example, using the same global config as above, given this project config: project : name : my-project regions : - us-east-2 s3_bucket : my-project-s3-bucket tests : default : template : ./template.yaml parameters : KeyPair : my-test-ec2-keypair Would result in this effective test configuration: tests : default : template : ./template.yaml s3_bucket : my-project-s3-bucket parameters : KeyPair : my-global-ec2-keypair Notice that s3_bucket took the most specific value and KeyPair the most general. CLI interface taskcat adopts a similar cli command structure to git with a taskcat command subcommand --flag style. The cli is also designed to be simplest if run from the root of a project. Let's have a look at equivalent command to run a test: cd into the project root and type test run : cd ./quickstart-aws-vpc taskcat test run or run it from anywhere by providing the path to the project root taskcat test run -p ./quickstart-aws-vpc Configuration files The configuration files required for taskcat have changed, to ease migration, if taskcat is run and legacy config files are found, they are converted and written to new file locations. For more information on the new format, see the config file docs .","title":"General Usage"},{"location":"docs/usage/GENERAL_USAGE/#usage","text":"","title":"Usage"},{"location":"docs/usage/GENERAL_USAGE/#cli","text":"The cli is self documenting by using --help . The most common use of taskcat is for executing function tests of CloudFormation templates. The command for this is: taskcat test run add --help to see the supported flags and arguments","title":"CLI"},{"location":"docs/usage/GENERAL_USAGE/#python","text":"Taskcat can be imported into Python and used in the testing framework of your choice. from taskcat.testing import CFNTest test = CFNTest . from_file ( project_root = './template_dir' ) with test as stacks : # Calling 'with' or 'test.run()' will deploy the stacks. for stack in stacks : print ( f \"Testing { stack . name } \" ) bucket_name = \"\" for output in stack . outputs : if output . key == \"LogsBucketName\" : bucket_name = output . value break assert \"logs\" in bucket_name assert stack . region . name in bucket_name print ( f \"Created bucket: { bucket_name } \" ) The example used here is very simple, you would most likely leverage other python modules like boto3 to do more advanced testing. The CFNTest object can be passed the same arguments as taskcat test run . See the docs for more details.","title":"Python"},{"location":"docs/usage/GENERAL_USAGE/#config-files","text":"taskcat has several configuration files which can be used to set behaviors in a flexible way.","title":"Config files"},{"location":"docs/usage/GENERAL_USAGE/#global-config","text":"~/.taskcat.yml provides global settings that become defaults for all projects. Please see our schema reference for specific configuration options that are available.","title":"Global config"},{"location":"docs/usage/GENERAL_USAGE/#project-config","text":"<PROJECT_ROOT>/.taskcat.yml provides project specific configuration. Please see our schema reference for specific configuration options that are available.","title":"Project config"},{"location":"docs/usage/GENERAL_USAGE/#precedence","text":"With the exception of the parameters section, more specific config with the same key takes precedence. The rationale behind having parameters function this way is so that values can be overridden at a system level outside of a project, that is likely committed to source control. parameters that define account specific things like VPC details, Key Pairs, or secrets like API keys can be defined per host outside of source control. For example, consider this global config: ~/.taskcat.yml general : s3_bucket : my-globally-defined-bucket parameters : KeyPair : my-global-ec2-keypair Given a simple project config: project : name : my-project regions : - us-east-2 tests : default : template : ./template.yaml The effective test configuration would become: tests : default : template : ./template.yaml s3_bucket : my-globally-defined-bucket parameters : KeyPair : my-global-ec2-keypair If any item is re-defined in a project it takes precedence over the global value. Anything defined in a test takes precedence over what is defined in the project or global configuration. with the exception of the parameters section which works in reverse. For example, using the same global config as above, given this project config: project : name : my-project regions : - us-east-2 s3_bucket : my-project-s3-bucket tests : default : template : ./template.yaml parameters : KeyPair : my-test-ec2-keypair Would result in this effective test configuration: tests : default : template : ./template.yaml s3_bucket : my-project-s3-bucket parameters : KeyPair : my-global-ec2-keypair Notice that s3_bucket took the most specific value and KeyPair the most general.","title":"Precedence"},{"location":"docs/usage/GENERAL_USAGE/#cli-interface","text":"taskcat adopts a similar cli command structure to git with a taskcat command subcommand --flag style. The cli is also designed to be simplest if run from the root of a project. Let's have a look at equivalent command to run a test: cd into the project root and type test run : cd ./quickstart-aws-vpc taskcat test run or run it from anywhere by providing the path to the project root taskcat test run -p ./quickstart-aws-vpc","title":"CLI interface"},{"location":"docs/usage/GENERAL_USAGE/#configuration-files","text":"The configuration files required for taskcat have changed, to ease migration, if taskcat is run and legacy config files are found, they are converted and written to new file locations. For more information on the new format, see the config file docs .","title":"Configuration files"},{"location":"docs/usage/PARAMETER_OVERRIDES/","text":"Parameter overrides Parameter Overrides were added to the taskcat to solve a couple of common problems. First, many templates share common parameters that are unique to an AWS account, like a KeyPair name or an S3 Bucket, overrides provided a way to store those centrally for all your projects. Second, we didn't want to add sensitive data (usernames, passwords, tokens) to a git repository. The idea was to store sensitive/unique data outside of a git repository, but still execute a test using this data. To that end, any parameter defined in the global config will take precedence over the same parameter in a project-level config .","title":"Parameter Overrides"},{"location":"docs/usage/PARAMETER_OVERRIDES/#parameter-overrides","text":"Parameter Overrides were added to the taskcat to solve a couple of common problems. First, many templates share common parameters that are unique to an AWS account, like a KeyPair name or an S3 Bucket, overrides provided a way to store those centrally for all your projects. Second, we didn't want to add sensitive data (usernames, passwords, tokens) to a git repository. The idea was to store sensitive/unique data outside of a git repository, but still execute a test using this data. To that end, any parameter defined in the global config will take precedence over the same parameter in a project-level config .","title":"Parameter overrides"},{"location":"docs/usage/PSUEDO_PARAMETERS/","text":"To increase the flexibility of taskcat, we've built-in support for psuedo-parameters that are transposed at runtime for actual values. Following table describes the supported psuedo-parameters . Psuedo-Parameter Example Value passed to the CloudFormation stack Details $[taskcat_autobucket] taskcat-tag-sample-taskcat-project-5fba6597 Note: The S3 Bucket is created $[taskcat_genaz_1] \"us-east-1a\" Fetches a single Availability Zone within the region being launched in $[taskcat_genaz_2] \"us-east-1a,us-east-1b\" Fetches two AvailabilityZones within the region being launched in $[taskcat_genaz_3] \"us-east-1a,us-east-1b,us-east-1c\" Fetches three AvailabilityZones within the region being launched in $[taskcat_genpass_8A] tI8zN3iX8 An alphanumeric 8-charater random password. The length is customizable. $[taskcat_genpass_8S] mA5@cB5! An alphanumeric 8-charater random password. The length is customizable. $[taskcat_random-string] yysuawpwubvotiqgwjcu Generates a random string $[taskcat_random-numbers] 56188163597280820763 Generates random numbers. $[taskcat_genuuid] 1c2e3483-2c99-45bb-801d-8af68a3b907b Generates a UUID $[taskcat_getval_MyAppPassword] Dynamically generated password for the MyAppPassword parameter Retreives another parameter value. $[taskcat_current_region] \"us-east-2\" Region the test is being prepared for $[taskcat_project_name] \"my-example-project\" Name of the project being tested $[taskcat_test_name] \"cluster-with-windows-ad\" Name of the test being tested $[taskcat_ssm_/path/to/ssm/parameter] SSM Parameter Value Retreives values from SSM $[taskcat_secretsmanager_SecretNameOrARN] Value from SecretsManager Retreives a secret value from SecretsManager given an name or ARN From: (defined in taskcat.yaml') InstanceType : t2.small AvailablityZones : $[taskcat_genaz_2] RandomString : $[taskcat_random-string] RandomNumbers : $[taskcat_random-numbers] GenerateUUID : $[taskcat_genuuid] Password : $[taskcat_genpass_8A] PasswordConfirm : $[taskcat_getval_Password] To: (At runtime passed to cloudformation API) InstanceType : t2.small AvailablityZones : us-east-1a : us-east1b RandomString : yysuawpwubvotiqgwjcu RandomNumbers : 56188163597280820763 GenerateUUID : 1c2e3483-2c99-45bb-801d-8af68a3b907b Password : tI8zN3iX8 PasswordConfirm : tI8zN3iX8","title":"Psuedo Parameters"},{"location":"docs/usage/PSUEDO_PARAMETERS/#from-defined-in-taskcatyaml","text":"InstanceType : t2.small AvailablityZones : $[taskcat_genaz_2] RandomString : $[taskcat_random-string] RandomNumbers : $[taskcat_random-numbers] GenerateUUID : $[taskcat_genuuid] Password : $[taskcat_genpass_8A] PasswordConfirm : $[taskcat_getval_Password]","title":"From: (defined in taskcat.yaml')"},{"location":"docs/usage/PSUEDO_PARAMETERS/#to-at-runtime-passed-to-cloudformation-api","text":"InstanceType : t2.small AvailablityZones : us-east-1a : us-east1b RandomString : yysuawpwubvotiqgwjcu RandomNumbers : 56188163597280820763 GenerateUUID : 1c2e3483-2c99-45bb-801d-8af68a3b907b Password : tI8zN3iX8 PasswordConfirm : tI8zN3iX8","title":"To: (At runtime passed to cloudformation API)"},{"location":"reference/taskcat/","text":"Module taskcat taskcat python module None View Source \"\"\" taskcat python module \"\"\" from ._cfn.stack import Stack # noqa: F401 from ._cfn.template import Template # noqa: F401 from ._cli import main # noqa: F401 from ._config import Config # noqa: F401 __all__ = [ \"Stack\" , \"Template\" , \"Config\" , \"main\" ] Sub-modules taskcat.exceptions taskcat.iam_policy taskcat.local_zones taskcat.regions_to_partitions taskcat.testing Functions main def main ( cli_core_class =< class ' taskcat . _cli_core . CliCore '>, exit_func =< function exit_with_code at 0x123263ee0 > ) View Source def main ( cli_core_class = CliCore , exit_func = exit_with_code ): signal . signal ( signal . SIGINT , _sigint_handler ) log_level = _setup_logging ( sys . argv ) args = sys . argv [ 1 :] if not args : args . append ( \"-h\" ) try : _welcome () version = get_installed_version () cli = cli_core_class ( NAME , _cli_modules , DESCRIPTION , version , GLOBAL_ARGS . ARGS ) cli . parse ( args ) _default_profile = cli . parsed_args . __dict__ . get ( \"_profile\" ) if _default_profile : GLOBAL_ARGS . profile = _default_profile cli . run () except TaskCatException as e : LOG . error ( str ( e ), exc_info = _print_tracebacks ( log_level )) exit_func ( 1 ) except Exception as e : # pylint: disable=broad-except LOG . error ( \" %s %s \" , e . __class__ . __name__ , str ( e ), exc_info = _print_tracebacks ( log_level ) ) exit_func ( 1 ) Classes Config class Config ( sources : list , uid : uuid . UUID , project_root : pathlib . Path ) View Source class Config : def __init__ ( self , sources : list , uid : uuid . UUID , project_root : Path ): self . config = BaseConfig . from_dict ( DEFAULTS ) self . config . set_source ( \"TASKCAT_DEFAULT\" ) self . project_root = project_root self . uid = uid for source in sources : config_dict : dict = source [ \"config\" ] source_name : str = source [ \"source\" ] source_config = BaseConfig . from_dict ( config_dict ) source_config . set_source ( source_name ) self . config = BaseConfig . merge ( self . config , source_config ) @ classmethod # pylint: disable=too-many-locals def create ( cls , template_file : Optional [ Path ] = None , args : Optional [ dict ] = None , global_config_path : Path = GENERAL , project_config_path : Path = PROJECT , overrides_path : Path = OVERRIDES , env_vars : Optional [ dict ] = None , project_root : Path = PROJECT_ROOT , uid : uuid . UUID = None , ) -> \"Config\" : uid = uid if uid else uuid . uuid4 () project_source = cls . _get_project_source ( cls , project_config_path , project_root , template_file ) # general legacy_overrides ( Path ( \"~/.aws/taskcat_global_override.json\" ) . expanduser () . resolve (), global_config_path , \"global\" , ) sources = [ { \"source\" : str ( global_config_path ), \"config\" : cls . _dict_from_file ( global_config_path ), } ] # project config file if project_source : sources . append ( project_source ) # template file if isinstance ( template_file , Path ): sources . append ( { \"source\" : str ( template_file ), \"config\" : cls . _dict_from_template ( template_file ), } ) # override file legacy_overrides ( project_root / \"ci/taskcat_project_override.json\" , overrides_path , \"project\" ) if overrides_path . is_file (): overrides = BaseConfig () . to_dict () with open ( str ( overrides_path ), \"r\" , encoding = \"utf-8\" ) as file_handle : override_params = yaml . safe_load ( file_handle ) overrides [ \"project\" ][ \"parameters\" ] = override_params sources . append ({ \"source\" : str ( overrides_path ), \"config\" : overrides }) # environment variables sources . append ( { \"source\" : \"EnvoronmentVariable\" , \"config\" : cls . _dict_from_env_vars ( env_vars ), } ) # cli arguments if args : sources . append ({ \"source\" : \"CliArgument\" , \"config\" : args }) return cls ( sources = sources , uid = uid , project_root = project_root ) # pylint: disable=protected-access,inconsistent-return-statements @ staticmethod def _get_project_source ( base_cls , project_config_path , project_root , template_file ): try : return { \"source\" : str ( project_config_path ), \"config\" : base_cls . _dict_from_file ( project_config_path , fail_ok = False ), } except FileNotFoundError as e : error = e try : legacy_conf = parse_legacy_config ( project_root ) return { \"source\" : str ( project_root / \"ci/taskcat.yml\" ), \"config\" : legacy_conf . to_dict (), } except Exception as e : # pylint: disable=broad-except,redefined-outer-name LOG . debug ( str ( e ), exc_info = True ) if not template_file : # pylint: disable=raise-missing-from raise error @ staticmethod def _dict_from_file ( file_path : Path , fail_ok = True ) -> dict : config_dict = BaseConfig () . to_dict () if not file_path . is_file () and fail_ok : return config_dict try : with open ( str ( file_path ), \"r\" , encoding = \"utf-8\" ) as file_handle : config_dict = yaml . safe_load ( file_handle ) return config_dict except Exception as e : # pylint: disable=broad-except LOG . warning ( f \"failed to load config from {file_path}\" ) LOG . debug ( str ( e ), exc_info = True ) if not fail_ok : raise e return config_dict @ staticmethod def _dict_from_template ( file_path : Path ) -> dict : relative_path = str ( file_path . relative_to ( PROJECT_ROOT )) config_dict = ( BaseConfig () . from_dict ( { \"project\" : { \"template\" : relative_path }, \"tests\" : { \"default\" : {}}} ) . to_dict () ) if not file_path . is_file (): raise TaskCatException ( f \"invalid template path {file_path}\" ) try : template = Template ( str ( file_path ), template_cache = tcat_template_cache ) . template except Exception as e : LOG . warning ( f \"failed to load template from {file_path}\" ) LOG . debug ( str ( e ), exc_info = True ) raise e if not template . get ( \"Metadata\" ): return config_dict if not template [ \"Metadata\" ] . get ( \"taskcat\" ): return config_dict template_config_dict = template [ \"Metadata\" ][ \"taskcat\" ] if not template_config_dict . get ( \"project\" ): template_config_dict [ \"project\" ] = {} template_config_dict [ \"project\" ][ \"template\" ] = relative_path if not template_config_dict . get ( \"tests\" ): template_config_dict [ \"tests\" ] = { \"default\" : {}} return template_config_dict # pylint: disable=protected-access @ staticmethod def _dict_from_env_vars ( env_vars : Optional [ Union [ os . _Environ , Dict [ str , str ]]] = None ): if env_vars is None : env_vars = os . environ config_dict : Dict [ str , Dict [ str , Union [ str , bool , int ]]] = {} for key , value in env_vars . items (): if key . startswith ( \"TASKCAT_\" ): key = key [ 8 :] . lower () sub_key = None key_section = None for section in [ \"general\" , \"project\" , \"tests\" ]: if key . startswith ( section ): sub_key = key [ len ( section ) + 1 :] key_section = section if isinstance ( sub_key , str ) and isinstance ( key_section , str ): if value . isnumeric (): value = int ( value ) elif value . lower () in [ \"true\" , \"false\" ]: value = value . lower () == \"true\" if not config_dict . get ( key_section ): config_dict [ key_section ] = {} config_dict [ key_section ][ sub_key ] = value return config_dict def _get_regions ( self , region_parameter_name , test , boto3_cache : Boto3Cache = None ): if boto3_cache is None : boto3_cache = Boto3Cache () region_object = {} for region in getattr ( test , region_parameter_name , []): # TODO: comon_utils/determine_profile_for_region profile = ( test . auth . get ( region , test . auth . get ( \"default\" , \"default\" )) if test . auth else \"default\" ) region_object [ region ] = RegionObj ( name = region , account_id = boto3_cache . account_id ( profile ), partition = boto3_cache . partition ( profile ), profile = profile , _boto3_cache = boto3_cache , taskcat_id = self . uid , _role_name = test . role_name , ) return region_object def get_regions ( self , boto3_cache : Boto3Cache = None ): region_objects : Dict [ str , Dict [ str , RegionObj ]] = {} for test_name , test in self . config . tests . items (): region_objects [ test_name ] = self . _get_regions ( \"regions\" , test , boto3_cache ) return region_objects def get_artifact_regions ( self , boto3_cache : Boto3Cache = None ): region_objects : Dict [ str , Dict [ str , RegionObj ]] = {} for test_name , test in self . config . tests . items (): if test . artifact_regions is not None : region_objects [ test_name ] = self . _get_regions ( \"artifact_regions\" , test , boto3_cache ) else : region_objects [ test_name ] = self . _get_regions ( \"regions\" , test , boto3_cache ) return region_objects def get_buckets ( self , boto3_cache : Boto3Cache = None ): regions = self . get_artifact_regions ( boto3_cache ) bucket_objects : Dict [ str , S3BucketObj ] = {} bucket_mappings : Dict [ str , Dict [ str , S3BucketObj ]] = {} for test_name , test in self . config . tests . items (): bucket_mappings [ test_name ] = {} for region_name , region in regions [ test_name ] . items (): if test . s3_regional_buckets : bucket_obj = self . _create_regional_bucket_obj ( bucket_objects , region , test ) bucket_objects [ f \"{region.account_id}{region.name}\" ] = bucket_obj else : bucket_obj = self . _create_legacy_bucket_obj ( bucket_objects , region , test ) bucket_objects [ region . account_id ] = bucket_obj bucket_mappings [ test_name ][ region_name ] = bucket_obj return bucket_mappings def _create_legacy_bucket_obj ( self , bucket_objects , region , test ): new = False object_acl = ( self . config . project . s3_object_acl if self . config . project . s3_object_acl else \"private\" ) sigv4 = not self . config . project . s3_enable_sig_v2 org_id = self . config . project . org_id if not test . s3_bucket and not bucket_objects . get ( region . account_id ): name = generate_bucket_name ( self . config . project . name ) auto_generated = True new = True elif bucket_objects . get ( region . account_id ): name = bucket_objects [ region . account_id ] . name auto_generated = bucket_objects [ region . account_id ] . auto_generated else : name = test . s3_bucket auto_generated = False bucket_region = self . _get_bucket_region_for_partition ( region . partition ) bucket_obj = S3BucketObj ( name = name , region = bucket_region , account_id = region . account_id , s3_client = region . session . client ( \"s3\" , region_name = bucket_region ), auto_generated = auto_generated , object_acl = object_acl , sigv4 = sigv4 , taskcat_id = self . uid , partition = region . partition , regional_buckets = test . s3_regional_buckets , org_id = org_id , ) if new : bucket_obj . create () return bucket_obj def _create_regional_bucket_obj ( self , bucket_objects , region , test ): _bucket_obj_key = f \"{region.account_id}{region.name}\" new = False object_acl = ( self . config . project . s3_object_acl if self . config . project . s3_object_acl else \"private\" ) sigv4 = not self . config . project . s3_enable_sig_v2 org_id = self . config . project . org_id if not test . s3_bucket and not bucket_objects . get ( _bucket_obj_key ): name = generate_regional_bucket_name ( region ) auto_generated = True new = True elif bucket_objects . get ( _bucket_obj_key ): name = bucket_objects [ _bucket_obj_key ] . name auto_generated = bucket_objects [ _bucket_obj_key ] . auto_generated else : name = f \"{test.s3_bucket}-{region.name}\" auto_generated = False try : region . client ( \"s3\" ) . head_bucket ( Bucket = name ) except ClientError as e : if \"(404)\" in str ( e ): new = True else : raise bucket_obj = S3BucketObj ( name = name , region = region . name , account_id = region . account_id , s3_client = region . session . client ( \"s3\" , region_name = region . name ), auto_generated = auto_generated , object_acl = object_acl , sigv4 = sigv4 , taskcat_id = self . uid , partition = region . partition , regional_buckets = test . s3_regional_buckets , org_id = org_id , ) if new : bucket_obj . create () return bucket_obj @ staticmethod def _get_bucket_region_for_partition ( partition ): region = \"us-east-1\" if partition == \"aws-us-gov\" : region = \"us-gov-east-1\" elif partition == \"aws-cn\" : region = \"cn-north-1\" return region def get_rendered_parameters ( self , bucket_objects , region_objects , template_objects ): parameters = {} template_params = self . get_params_from_templates ( template_objects ) for test_name , test in self . config . tests . items (): parameters [ test_name ] = {} for region_name in test . regions : region_params = template_params [ test_name ] . copy () for param_key , param_value in test . parameters . items (): if param_key in region_params : region_params [ param_key ] = param_value region = region_objects [ test_name ][ region_name ] s3bucket = bucket_objects [ test_name ][ region_name ] parameters [ test_name ][ region_name ] = ParamGen ( self . project_root , region_params , s3bucket . name , region . name , region . client , self . config . project . name , test_name , test . az_blacklist , ) . results return parameters @ staticmethod def get_params_from_templates ( template_objects ): parameters = {} for test_name , template in template_objects . items (): parameters [ test_name ] = template . parameters () return parameters def get_templates ( self ): templates = {} for test_name , test in self . config . tests . items (): templates [ test_name ] = Template ( template_path = self . project_root / test . template , project_root = self . project_root , s3_key_prefix = f \"{self.config.project.name}/\" , template_cache = tcat_template_cache , ) return templates def get_tests ( self , templates , regions , buckets , parameters ): tests = {} for test_name , test in self . config . tests . items (): region_list = [] artifact_region_list = [] tag_list = [] if test . tags : for tag_key , tag_value in test . tags . items (): tag_list . append ( Tag ({ \"Key\" : tag_key , \"Value\" : tag_value })) for region_obj in regions [ test_name ] . values (): region_list . append ( TestRegion . from_region_obj ( region_obj , buckets [ test_name ][ region_obj . name ], parameters [ test_name ][ region_obj . name ], ) ) tests [ test_name ] = TestObj ( name = test_name , template_path = self . project_root / test . template , template = templates [ test_name ], project_root = self . project_root , regions = region_list , artifact_regions = artifact_region_list , tags = tag_list , uid = self . uid , _project_name = self . config . project . name , _shorten_stack_name = self . config . project . shorten_stack_name , _stack_name = test . stack_name , _stack_name_prefix = test . stack_name_prefix , _stack_name_suffix = test . stack_name_suffix , ) return tests Static methods create def create ( template_file : Union [ pathlib . Path , NoneType ] = None , args : Union [ dict , NoneType ] = None , global_config_path : pathlib . Path = PosixPath ( '/Users/tonynv/.taskcat.yml' ), project_config_path : pathlib . Path = PosixPath ( '/Users/tonynv/work/github/tonynv/taskcat/.taskcat.yml' ), overrides_path : pathlib . Path = PosixPath ( '/Users/tonynv/work/github/tonynv/taskcat/.taskcat_overrides.yml' ), env_vars : Union [ dict , NoneType ] = None , project_root : pathlib . Path = PosixPath ( '/Users/tonynv/work/github/tonynv/taskcat' ), uid : uuid . UUID = None ) -> 'Config' View Source @ classmethod # pylint: disable=too-many-locals def create ( cls , template_file : Optional [ Path ] = None , args : Optional [ dict ] = None , global_config_path : Path = GENERAL , project_config_path : Path = PROJECT , overrides_path : Path = OVERRIDES , env_vars : Optional [ dict ] = None , project_root : Path = PROJECT_ROOT , uid : uuid . UUID = None , ) -> \"Config\" : uid = uid if uid else uuid . uuid4 () project_source = cls . _get_project_source ( cls , project_config_path , project_root , template_file ) # general legacy_overrides ( Path ( \"~/.aws/taskcat_global_override.json\" ) . expanduser () . resolve (), global_config_path , \"global\" , ) sources = [ { \"source\" : str ( global_config_path ), \"config\" : cls . _dict_from_file ( global_config_path ), } ] # project config file if project_source : sources . append ( project_source ) # template file if isinstance ( template_file , Path ): sources . append ( { \"source\" : str ( template_file ), \"config\" : cls . _dict_from_template ( template_file ), } ) # override file legacy_overrides ( project_root / \"ci/taskcat_project_override.json\" , overrides_path , \"project\" ) if overrides_path . is_file (): overrides = BaseConfig () . to_dict () with open ( str ( overrides_path ), \"r\" , encoding = \"utf-8\" ) as file_handle : override_params = yaml . safe_load ( file_handle ) overrides [ \"project\" ][ \"parameters\" ] = override_params sources . append ({ \"source\" : str ( overrides_path ), \"config\" : overrides }) # environment variables sources . append ( { \"source\" : \"EnvoronmentVariable\" , \"config\" : cls . _dict_from_env_vars ( env_vars ), } ) # cli arguments if args : sources . append ({ \"source\" : \"CliArgument\" , \"config\" : args }) return cls ( sources = sources , uid = uid , project_root = project_root ) get_params_from_templates def get_params_from_templates ( template_objects ) View Source @staticmethod def get_params_from_templates ( template_objects ) : parameters = {} for test_name , template in template_objects . items () : parameters [ test_name ] = template . parameters () return parameters Methods get_artifact_regions def get_artifact_regions ( self , boto3_cache : taskcat . _client_factory . Boto3Cache = None ) View Source def get_artifact_regions ( self , boto3_cache : Boto3Cache = None ) : region_objects : Dict [ str, Dict[str, RegionObj ] ] = {} for test_name , test in self . config . tests . items () : if test . artifact_regions is not None : region_objects [ test_name ] = self . _get_regions ( \"artifact_regions\" , test , boto3_cache ) else : region_objects [ test_name ] = self . _get_regions ( \"regions\" , test , boto3_cache ) return region_objects get_buckets def get_buckets ( self , boto3_cache : taskcat . _client_factory . Boto3Cache = None ) View Source def get_buckets ( self , boto3_cache : Boto3Cache = None ) : regions = self . get_artifact_regions ( boto3_cache ) bucket_objects : Dict [ str, S3BucketObj ] = {} bucket_mappings : Dict [ str, Dict[str, S3BucketObj ] ] = {} for test_name , test in self . config . tests . items () : bucket_mappings [ test_name ] = {} for region_name , region in regions [ test_name ] . items () : if test . s3_regional_buckets : bucket_obj = self . _create_regional_bucket_obj ( bucket_objects , region , test ) bucket_objects [ f\"{region.account_id}{region.name}\" ] = bucket_obj else : bucket_obj = self . _create_legacy_bucket_obj ( bucket_objects , region , test ) bucket_objects [ region.account_id ] = bucket_obj bucket_mappings [ test_name ][ region_name ] = bucket_obj return bucket_mappings get_regions def get_regions ( self , boto3_cache : taskcat . _client_factory . Boto3Cache = None ) View Source def get_regions ( self , boto3_cache : Boto3Cache = None ) : region_objects : Dict [ str, Dict[str, RegionObj ] ] = {} for test_name , test in self . config . tests . items () : region_objects [ test_name ] = self . _get_regions ( \"regions\" , test , boto3_cache ) return region_objects get_rendered_parameters def get_rendered_parameters ( self , bucket_objects , region_objects , template_objects ) View Source def get_rendered_parameters ( self , bucket_objects , region_objects , template_objects ) : parameters = {} template_params = self . get_params_from_templates ( template_objects ) for test_name , test in self . config . tests . items () : parameters [ test_name ] = {} for region_name in test . regions : region_params = template_params [ test_name ] . copy () for param_key , param_value in test . parameters . items () : if param_key in region_params : region_params [ param_key ] = param_value region = region_objects [ test_name ][ region_name ] s3bucket = bucket_objects [ test_name ][ region_name ] parameters [ test_name ][ region_name ] = ParamGen ( self . project_root , region_params , s3bucket . name , region . name , region . client , self . config . project . name , test_name , test . az_blacklist , ). results return parameters get_templates def get_templates ( self ) View Source def get_templates ( self ) : templates = {} for test_name , test in self . config . tests . items () : templates [ test_name ] = Template ( template_path = self . project_root / test . template , project_root = self . project_root , s3_key_prefix = f \"{self.config.project.name}/\" , template_cache = tcat_template_cache , ) return templates get_tests def get_tests ( self , templates , regions , buckets , parameters ) View Source def get_tests ( self , templates , regions , buckets , parameters ) : tests = {} for test_name , test in self . config . tests . items () : region_list = [] artifact_region_list = [] tag_list = [] if test . tags : for tag_key , tag_value in test . tags . items () : tag_list . append ( Tag ( { \"Key\" : tag_key , \"Value\" : tag_value } )) for region_obj in regions [ test_name ] . values () : region_list . append ( TestRegion . from_region_obj ( region_obj , buckets [ test_name ][ region_obj.name ] , parameters [ test_name ][ region_obj.name ] , ) ) tests [ test_name ] = TestObj ( name = test_name , template_path = self . project_root / test . template , template = templates [ test_name ] , project_root = self . project_root , regions = region_list , artifact_regions = artifact_region_list , tags = tag_list , uid = self . uid , _project_name = self . config . project . name , _shorten_stack_name = self . config . project . shorten_stack_name , _stack_name = test . stack_name , _stack_name_prefix = test . stack_name_prefix , _stack_name_suffix = test . stack_name_suffix , ) return tests Stack class Stack ( region : taskcat . _dataclasses . TestRegion , stack_id : str , template : taskcat . _cfn . template . Template , test_name , uuid : uuid . UUID = None ) View Source class Stack : # pylint: disable=too-many-instance-attributes REMOTE_TEMPLATE_PATH = Path ( \".taskcat/.remote_templates\" ) def __init__ ( self , region : TestRegion , stack_id : str , template : Template , test_name , uuid : UUID = None , ): uuid = uuid if uuid else uuid4 () self . test_name : str = test_name self . uuid : UUID = uuid self . id : str = stack_id self . template : Template = template self . name : str = self . _get_name () self . region : TestRegion = region self . region_name = region . name self . client : boto3 . client = region . client ( \"cloudformation\" ) self . completion_time : timedelta = timedelta ( 0 ) self . role_arn = region . role_arn # properties from additional cfn api calls self . _events : Events = Events () self . _resources : Resources = Resources () self . _children : Stacks = Stacks () # properties from describe_stacks response self . change_set_id : str = \"\" self . parameters : List [ Parameter ] = [] self . creation_time : datetime = datetime . fromtimestamp ( 0 ) self . deletion_time : datetime = datetime . fromtimestamp ( 0 ) self . _status : str = \"\" self . status_reason : str = \"\" self . disable_rollback : bool = False self . timeout_in_minutes : int = 0 self . capabilities : List [ str ] = [] self . outputs : List [ Output ] = [] self . tags : List [ Tag ] = [] self . parent_id : str = \"\" self . root_id : str = \"\" self . _launch_succeeded : bool = False self . _auto_refresh_interval : timedelta = timedelta ( seconds = 60 ) self . _last_event_refresh : datetime = datetime . fromtimestamp ( 0 ) self . _last_resource_refresh : datetime = datetime . fromtimestamp ( 0 ) self . _last_child_refresh : datetime = datetime . fromtimestamp ( 0 ) self . _timer = Timer ( self . _auto_refresh_interval . total_seconds (), self . refresh ) self . _timer . start () def __str__ ( self ): return self . id def __repr__ ( self ): return \"<Stack object {} at {}>\" . format ( self . name , hex ( id ( self ))) def _get_region ( self ) -> str : return self . id . split ( \":\" )[ 3 ] def _get_name ( self ) -> str : return self . id . split ( \":\" )[ 5 ] . split ( \"/\" )[ 1 ] def _auto_refresh ( self , last_refresh ): if datetime . now () - last_refresh > self . _auto_refresh_interval : return True return False @ property def status ( self ): if self . _status in StackStatus . COMPLETE : if not self . launch_succeeded : self . _status = \"OUT_OF_ORDER_EVENT\" self . status_reason = ( \"COMPLETE event not detected. \" + \"Potential out-of-band action against the stack.\" ) return self . _status @ status . setter def status ( self , status ): _complete = StackStatus . COMPLETE . copy () del _complete [ _complete . index ( \"DELETE_COMPLETE\" )] self . _status = status if status in StackStatus . FAILED : self . _launch_succeeded = False return if status in _complete : self . _launch_succeeded = True return return @ property def launch_succeeded ( self ): return self . _launch_succeeded @ classmethod def create ( cls , region : TestRegion , stack_name : str , template : Template , tags : List [ Tag ] = None , disable_rollback : bool = True , test_name : str = \"\" , uuid : UUID = None , ) -> \"Stack\" : parameters = cls . _cfn_format_parameters ( region . parameters ) uuid = uuid if uuid else uuid4 () cfn_client = region . client ( \"cloudformation\" ) tags = [ t . dump () for t in tags ] if tags else [] template = Template ( template_path = template . template_path , project_root = template . project_root , s3_key_prefix = template . s3_key_prefix , url = s3_url_maker ( region . s3_bucket . name , template . s3_key , region . client ( \"s3\" ), region . s3_bucket . auto_generated , ), template_cache = tcat_template_cache , ) create_options = { \"StackName\" : stack_name , \"TemplateURL\" : template . url , \"Parameters\" : parameters , \"DisableRollback\" : disable_rollback , \"Tags\" : tags , \"Capabilities\" : Capabilities . ALL , } if region . role_arn : create_options [ \"RoleARN\" ] = region . role_arn stack_id = cfn_client . create_stack ( ** create_options )[ \"StackId\" ] stack = cls ( region , stack_id , template , test_name , uuid ) # fetch property values from cfn stack . refresh () return stack @ staticmethod def _cfn_format_parameters ( parameters ): return [{ \"ParameterKey\" : k , \"ParameterValue\" : v } for k , v in parameters . items ()] @ classmethod def _import_child ( # pylint: disable=too-many-locals cls , stack_properties : dict , parent_stack : \"Stack\" ) -> Optional [ \"Stack\" ]: try : url = \"\" for event in parent_stack . events (): if ( event . physical_id == stack_properties [ \"StackId\" ] and event . properties ): url = event . properties [ \"TemplateURL\" ] if url . startswith ( parent_stack . template . url_prefix ()): # Template is part of the project, discovering path relative_path = url . replace ( parent_stack . template . url_prefix (), \"\" ) . lstrip ( \"/\" ) absolute_path = parent_stack . template . project_root / relative_path if not absolute_path . is_file (): # try with the base folder stripped off relative_path2 = Path ( relative_path ) relative_path2 = relative_path2 . relative_to ( * relative_path2 . parts [: 1 ] ) absolute_path = parent_stack . template . project_root / relative_path2 if not absolute_path . is_file (): LOG . warning ( f \"Failed to find template for child stack \" f \"{stack_properties['StackId']}. tried \" f \"{parent_stack.template.project_root / relative_path}\" f \" and {absolute_path}\" ) return None else : # Assuming template is remote to project and downloading it cfn_client = parent_stack . client tempate_body = cfn_client . get_template ( StackName = stack_properties [ \"StackId\" ] )[ \"TemplateBody\" ] path = parent_stack . template . project_root / Stack . REMOTE_TEMPLATE_PATH os . makedirs ( path , exist_ok = True ) fname = ( \"\" . join ( random . choice ( string . ascii_lowercase ) # nosec for _ in range ( 16 ) ) + \".template\" ) absolute_path = path / fname if not isinstance ( tempate_body , str ): tempate_body = ordered_dump ( tempate_body , dumper = yaml . SafeDumper ) if not absolute_path . exists (): with open ( absolute_path , \"w\" , encoding = \"utf-8\" ) as fh : fh . write ( tempate_body ) template = Template ( template_path = str ( absolute_path ), project_root = parent_stack . template . project_root , url = url , template_cache = tcat_template_cache , ) stack = cls ( parent_stack . region , stack_properties [ \"StackId\" ], template , parent_stack . name , parent_stack . uuid , ) stack . set_stack_properties ( stack_properties ) except Exception as e : # pylint: disable=broad-except LOG . warning ( f \"Failed to import child stack: {str(e)}\" ) LOG . debug ( \"traceback:\" , exc_info = True ) return None return stack @ classmethod def import_existing ( cls , stack_properties : dict , template : Template , region : TestRegion , test_name : str , uid : UUID , ) -> \"Stack\" : stack = cls ( region , stack_properties [ \"StackId\" ], template , test_name , uid ) stack . set_stack_properties ( stack_properties ) return stack def refresh ( self , properties : bool = True , events : bool = False , resources : bool = False , children : bool = False , ) -> None : if properties : self . set_stack_properties () if events : self . _fetch_stack_events () self . _last_event_refresh = datetime . now () if resources : self . _fetch_stack_resources () self . _last_resource_refresh = datetime . now () if children : self . _fetch_children () self . _last_child_refresh = datetime . now () def set_stack_properties ( self , stack_properties : Optional [ dict ] = None ) -> None : # TODO: get time to complete for complete stacks and % complete props : dict = stack_properties if stack_properties else {} self . _timer . cancel () if not props : describe_stacks = self . client . describe_stacks props = describe_stacks ( StackName = self . id )[ \"Stacks\" ][ 0 ] iterable_props : List [ Tuple [ str , Callable ]] = [ ( \"Parameters\" , Parameter ), ( \"Outputs\" , Output ), ( \"Tags\" , Tag ), ] for prop_name , prop_class in iterable_props : for item in props . get ( prop_name , []): item = prop_class ( item ) self . _merge_props ( getattr ( self , prop_name . lower ()), item ) for key , value in props . items (): if key in [ p [ 0 ] for p in iterable_props ]: # noqa: C412 continue key = pascal_to_snake ( key ) . replace ( \"stack_\" , \"\" ) setattr ( self , key , value ) if self . status in StackStatus . IN_PROGRESS : self . _timer = Timer ( self . _auto_refresh_interval . total_seconds (), self . refresh ) self . _timer . start () @ staticmethod def _merge_props ( existing_props , new ): added = False for existing_id , prop in enumerate ( existing_props ): if prop . key == new . key : existing_props [ existing_id ] = new added = True if not added : existing_props . append ( new ) def events ( self , refresh : bool = False , include_generic : bool = True ) -> Events : if refresh or not self . _events or self . _auto_refresh ( self . _last_event_refresh ): self . _fetch_stack_events () events = self . _events if not include_generic : events = Events ([ event for event in events if not self . _is_generic ( event )]) return events @ staticmethod def _is_generic ( event : Event ) -> bool : generic = False for regex in GENERIC_ERROR_PATTERNS : if re . search ( regex , event . status_reason ): generic = True return generic def _fetch_stack_events ( self ) -> None : self . _last_event_refresh = datetime . now () events = Events () for page in self . client . get_paginator ( \"describe_stack_events\" ) . paginate ( StackName = self . id ): for event in page [ \"StackEvents\" ]: events . append ( Event ( event )) self . _events = events def resources ( self , refresh : bool = False ) -> Resources : if ( refresh or not self . _resources or self . _auto_refresh ( self . _last_resource_refresh ) ): self . _fetch_stack_resources () return self . _resources def _fetch_stack_resources ( self ) -> None : self . _last_resource_refresh = datetime . now () resources = Resources () for page in self . client . get_paginator ( \"list_stack_resources\" ) . paginate ( StackName = self . id ): for resource in page [ \"StackResourceSummaries\" ]: resources . append ( Resource ( self . id , resource , self . test_name , self . uuid )) self . _resources = resources @ staticmethod def delete ( client , stack_id ) -> None : client . delete_stack ( StackName = stack_id ) LOG . info ( f \"Deleting stack: {stack_id}\" ) def update ( self , * args , ** kwargs ): raise NotImplementedError ( \"Stack updates not implemented\" ) def _fetch_children ( self ) -> None : self . _last_child_refresh = datetime . now () for page in self . client . get_paginator ( \"describe_stacks\" ) . paginate (): for stack in page [ \"Stacks\" ]: if self . _children . filter ( id = stack [ \"StackId\" ]): continue if \"ParentId\" in stack . keys (): if self . id == stack [ \"ParentId\" ]: stack_obj = Stack . _import_child ( stack , self ) if stack_obj : self . _children . append ( stack_obj ) def children ( self , refresh = False ) -> Stacks : if ( refresh or not self . _children or self . _auto_refresh ( self . _last_child_refresh ) ): self . _fetch_children () return self . _children def descendants ( self , refresh = False ) -> Stacks : if refresh or not self . _children : self . _fetch_children () def recurse ( stack : Stack , descendants : Stacks = None ) -> Stacks : descendants = descendants if descendants else Stacks () if stack . children ( refresh = refresh ): descendants += stack . children () for child in stack . children (): descendants = recurse ( child , descendants ) return descendants return recurse ( self ) def error_events ( self , recurse : bool = True , include_generic : bool = False , refresh = False ) -> Events : errors = Events () stacks = Stacks ([ self ]) if recurse : stacks += self . descendants () for stack in stacks : for status in StackStatus . FAILED : errors += stack . events ( refresh = refresh , include_generic = include_generic ) . filter ({ \"status\" : status }) return errors Class variables REMOTE_TEMPLATE_PATH Static methods create def create ( region : taskcat . _dataclasses . TestRegion , stack_name : str , template : taskcat . _cfn . template . Template , tags : List [ taskcat . _dataclasses . Tag ] = None , disable_rollback : bool = True , test_name : str = '' , uuid : uuid . UUID = None ) -> 'Stack' View Source @classmethod def create ( cls , region : TestRegion , stack_name : str , template : Template , tags : List [ Tag ] = None , disable_rollback : bool = True , test_name : str = \"\" , uuid : UUID = None , ) -> \"Stack\" : parameters = cls . _cfn_format_parameters ( region . parameters ) uuid = uuid if uuid else uuid4 () cfn_client = region . client ( \"cloudformation\" ) tags = [ t.dump() for t in tags ] if tags else [] template = Template ( template_path = template . template_path , project_root = template . project_root , s3_key_prefix = template . s3_key_prefix , url = s3_url_maker ( region . s3_bucket . name , template . s3_key , region . client ( \"s3\" ), region . s3_bucket . auto_generated , ), template_cache = tcat_template_cache , ) create_options = { \"StackName\" : stack_name , \"TemplateURL\" : template . url , \"Parameters\" : parameters , \"DisableRollback\" : disable_rollback , \"Tags\" : tags , \"Capabilities\" : Capabilities . ALL , } if region . role_arn : create_options [ \"RoleARN\" ] = region . role_arn stack_id = cfn_client . create_stack ( ** create_options ) [ \"StackId\" ] stack = cls ( region , stack_id , template , test_name , uuid ) # fetch property values from cfn stack . refresh () return stack delete def delete ( client , stack_id ) -> None View Source @staticmethod def delete ( client , stack_id ) -> None : client . delete_stack ( StackName = stack_id ) LOG . info ( f \"Deleting stack: {stack_id}\" ) import_existing def import_existing ( stack_properties : dict , template : taskcat . _cfn . template . Template , region : taskcat . _dataclasses . TestRegion , test_name : str , uid : uuid . UUID ) -> 'Stack' View Source @classmethod def import_existing ( cls , stack_properties : dict , template : Template , region : TestRegion , test_name : str , uid : UUID , ) -> \"Stack\" : stack = cls ( region , stack_properties [ \"StackId\" ] , template , test_name , uid ) stack . set_stack_properties ( stack_properties ) return stack Instance variables launch_succeeded status Methods children def children ( self , refresh = False ) -> taskcat . _cfn . stack . Stacks View Source def children ( self , refresh = False ) -> Stacks : if ( refresh or not self . _children or self . _auto_refresh ( self . _last_child_refresh ) ) : self . _fetch_children () return self . _children descendants def descendants ( self , refresh = False ) -> taskcat . _cfn . stack . Stacks View Source def descendants ( self , refresh = False ) -> Stacks : if refresh or not self . _children : self . _fetch_children () def recurse ( stack : Stack , descendants : Stacks = None ) -> Stacks : descendants = descendants if descendants else Stacks () if stack . children ( refresh = refresh ) : descendants += stack . children () for child in stack . children () : descendants = recurse ( child , descendants ) return descendants return recurse ( self ) error_events def error_events ( self , recurse : bool = True , include_generic : bool = False , refresh = False ) -> taskcat . _cfn . stack . Events View Source def error_events ( self , recurse : bool = True , include_generic : bool = False , refresh = False ) -> Events : errors = Events () stacks = Stacks ( [ self ] ) if recurse : stacks += self . descendants () for stack in stacks : for status in StackStatus . FAILED : errors += stack . events ( refresh = refresh , include_generic = include_generic ). filter ( { \"status\" : status } ) return errors events def events ( self , refresh : bool = False , include_generic : bool = True ) -> taskcat . _cfn . stack . Events View Source def events ( self , refresh : bool = False , include_generic : bool = True ) -> Events : if refresh or not self . _events or self . _auto_refresh ( self . _last_event_refresh ) : self . _fetch_stack_events () events = self . _events if not include_generic : events = Events ([ event for event in events if not self . _is_generic ( event )]) return events refresh def refresh ( self , properties : bool = True , events : bool = False , resources : bool = False , children : bool = False ) -> None View Source def refresh ( self , properties : bool = True , events : bool = False , resources : bool = False , children : bool = False , ) -> None : if properties : self . set_stack_properties () if events : self . _fetch_stack_events () self . _last_event_refresh = datetime . now () if resources : self . _fetch_stack_resources () self . _last_resource_refresh = datetime . now () if children : self . _fetch_children () self . _last_child_refresh = datetime . now () resources def resources ( self , refresh : bool = False ) -> taskcat . _cfn . stack . Resources View Source def resources ( self , refresh : bool = False ) -> Resources : if ( refresh or not self . _resources or self . _auto_refresh ( self . _last_resource_refresh ) ) : self . _fetch_stack_resources () return self . _resources set_stack_properties def set_stack_properties ( self , stack_properties : Union [ dict , NoneType ] = None ) -> None View Source def set_stack_properties ( self , stack_properties : Optional [ dict ] = None ) -> None : # TODO : get time to complete for complete stacks and % complete props : dict = stack_properties if stack_properties else {} self . _timer . cancel () if not props : describe_stacks = self . client . describe_stacks props = describe_stacks ( StackName = self . id ) [ \"Stacks\" ][ 0 ] iterable_props : List [ Tuple[str, Callable ] ] = [ (\"Parameters\", Parameter), (\"Outputs\", Output), (\"Tags\", Tag), ] for prop_name , prop_class in iterable_props : for item in props . get ( prop_name , [] ) : item = prop_class ( item ) self . _merge_props ( getattr ( self , prop_name . lower ()), item ) for key , value in props . items () : if key in [ p[0 ] for p in iterable_props ]: # noqa : C412 continue key = pascal_to_snake ( key ). replace ( \"stack_\" , \"\" ) setattr ( self , key , value ) if self . status in StackStatus . IN_PROGRESS : self . _timer = Timer ( self . _auto_refresh_interval . total_seconds (), self . refresh ) self . _timer . start () update def update ( self , * args , ** kwargs ) View Source def update(self, *args, **kwargs): raise NotImplementedError(\"Stack updates not implemented\") Template class Template ( template_path : Union [ str , pathlib . Path ], project_root : Union [ str , pathlib . Path ] = '' , url : str = '' , s3_key_prefix : str = '' , template_cache : taskcat . _cfn . template . TemplateCache = < taskcat . _cfn . template . TemplateCache object at 0x10e045490 > ) View Source class Template : def __ init__ ( self , template_path : Union [ str , Path ], project_root : Union [ str , Path ] = \"\" , url : str = \"\" , s3_key_prefix : str = \"\" , template_cache : TemplateCache = tcat_template_cache , ) : self . template_cache = template_cache self . template_path : Path = Path ( template_path ). expanduser (). resolve () self . template = self . template_cache . get ( str ( self . template_path )) with open ( template_path , \"r\" , encoding= \"utf-8\" ) as file_handle : self . raw_template = file_handle . read () project_root = ( project_root if project_root else self . template_path . parent . parent ) self . project_root = Path ( project_root ). expanduser (). resolve () self . url = url self . _ s3_key_prefix = s3_key_prefix self . children : List [ Template ] = [] self . _ find_children () def __ str__ ( self ) : return str ( self . template ) def __ repr__ ( self ) : return f \"<Template {self.template_path} at {hex(id(self))}>\" @property def s3_key ( self ) : suffix = str ( self . template_path . relative_to ( self . project_root ). as_posix ()) return self . _ s3_key_prefix + suffix @property def s3_key_prefix ( self ) : return self . _ s3_key_prefix @property def linesplit ( self ) : return self . raw_template . split ( \"\\n\" ) def write ( self ) : \"\"\"writes raw_template back to file, and reloads decoded template, useful if the template has been modified\"\"\" with open ( str ( self . template_path ), \"w\" , encoding= \"utf-8\" ) as file_handle : file_handle . write ( self . raw_template ) self . template = cfnlint . decode . cfn_yaml . load ( self . template_path ) self . _ find_children () def _ template_url_to_path ( self , template_url , template_mappings = None , ) : try : helper = StackURLHelper ( template_mappings = template_mappings , template_parameters = self . template . get ( \"Parameters\" ), ) urls = helper . template_url_to_path ( current_template_path = self . template_path , template_url = template_url ) if len ( urls ) > 0 : return urls [ 0 ] except Exception as e : # pylint : disable = broad - except LOG . debug ( \"Traceback:\" , exc_info = True ) LOG . error ( \"TemplateURL parsing error: %s \" % str(e)) LOG . warning ( \"Failed to discover path for %s, path %s does not exist\" , template_url , None , ) return \"\" def _ get_relative_url ( self , path : str ) -> str : suffix = str ( path ). replace ( str ( self . project_root ), \"\" ) url = self . url_prefix () + suffix return url def url_prefix ( self ) -> str : if not self . url : return \"\" regionless_url = re . sub ( r \" \\.s3\\. (. * ) \\.amazonaws\\.com \", \" . s3 . amazonaws . com \", self.url, ) suffix = str(self.template_path).replace(str(self.project_root), \"\") suffix_length = len(suffix.lstrip(\" / \").split(\" / \")) url_prefix = \" / \".join(regionless_url.split(\" / \")[0:-suffix_length]) return url_prefix def _find_children(self) -> None: # noqa: C901 children = set() if \" Resources \" not in self.template: raise TaskCatException( f\" did not receive a val id template : { self . template_path } does not \" f\" have a Resources section \" ) for resource in self.template[\" Resources \"].keys(): resource = self.template[\" Resources \"][resource] if resource[\" Type \"] == \" AWS :: CloudFormation :: Stack \": child_name = self._template_url_to_path( template_url=resource[\" Properties \"][\" TemplateURL \"], ) # print(child_name) if child_name: # for child_url in child_name: children.add(child_name) for child in children: child_template_instance = None for descendent in self.descendents: if str(descendent.template_path) == str(child): child_template_instance = descendent if not child_template_instance: try: child_template_instance = Template( child, self.project_root, self._get_relative_url(child), self._s3_key_prefix, tcat_template_cache, ) except Exception: # pylint: disable=broad-except LOG.debug(\" Traceback : \", exc_info=True) LOG.error(f\" Failed to add child template { child } \") if isinstance(child_template_instance, Template): self.children.append(child_template_instance) @property def descendents(self) -> List[\" Template \"]: desc_map = {} def recurse(template): for child in template.children: desc_map[str(child.template_path)] = child recurse(child) recurse(self) return list(desc_map.values()) def parameters( self, ) -> Dict[str, Union[None, str, int, bool, List[Union[int, str]]]]: parameters = {} for param_key, param in self.template.get(\" Parameters \", {}).items(): parameters[param_key] = param.get(\" Default \" ) return parameters Instance variables descendents linesplit s3_key s3_key_prefix Methods parameters def parameters ( self ) -> Dict [ str , Union [ NoneType , str , int , bool , List [ Union [ str , int ]]]] View Source def parameters ( self , ) -> Dict [ str, Union[None, str, int, bool, List[Union[int, str ] ]]]: parameters = {} for param_key , param in self . template . get ( \"Parameters\" , {} ). items () : parameters [ param_key ] = param . get ( \"Default\" ) return parameters url_prefix def url_prefix ( self ) -> str View Source def url_prefix ( self ) -> str : if not self . url : return \"\" regionless_url = re . sub ( r \" \\.s3\\. (. * ) \\.amazonaws\\.com \", \" . s3 . amazonaws . com \", self.url, ) suffix = str(self.template_path).replace(str(self.project_root), \"\") suffix_length = len(suffix.lstrip(\" / \").split(\" / \")) url_prefix = \" / \".join(regionless_url.split(\" / \" )[ 0 :- suffix_length ]) return url_prefix write def write ( self ) writes raw_template back to file, and reloads decoded template, useful if the template has been modified View Source def write ( self ): \"\"\"writes raw_template back to file, and reloads decoded template, useful if the template has been modified\"\"\" with open ( str ( self . template_path ), \"w\" , encoding = \"utf-8\" ) as file_handle : file_handle . write ( self . raw_template ) self . template = cfnlint . decode . cfn_yaml . load ( self . template_path ) self . _find_children ()","title":"Index"},{"location":"reference/taskcat/#module-taskcat","text":"taskcat python module None View Source \"\"\" taskcat python module \"\"\" from ._cfn.stack import Stack # noqa: F401 from ._cfn.template import Template # noqa: F401 from ._cli import main # noqa: F401 from ._config import Config # noqa: F401 __all__ = [ \"Stack\" , \"Template\" , \"Config\" , \"main\" ]","title":"Module taskcat"},{"location":"reference/taskcat/#sub-modules","text":"taskcat.exceptions taskcat.iam_policy taskcat.local_zones taskcat.regions_to_partitions taskcat.testing","title":"Sub-modules"},{"location":"reference/taskcat/#functions","text":"","title":"Functions"},{"location":"reference/taskcat/#main","text":"def main ( cli_core_class =< class ' taskcat . _cli_core . CliCore '>, exit_func =< function exit_with_code at 0x123263ee0 > ) View Source def main ( cli_core_class = CliCore , exit_func = exit_with_code ): signal . signal ( signal . SIGINT , _sigint_handler ) log_level = _setup_logging ( sys . argv ) args = sys . argv [ 1 :] if not args : args . append ( \"-h\" ) try : _welcome () version = get_installed_version () cli = cli_core_class ( NAME , _cli_modules , DESCRIPTION , version , GLOBAL_ARGS . ARGS ) cli . parse ( args ) _default_profile = cli . parsed_args . __dict__ . get ( \"_profile\" ) if _default_profile : GLOBAL_ARGS . profile = _default_profile cli . run () except TaskCatException as e : LOG . error ( str ( e ), exc_info = _print_tracebacks ( log_level )) exit_func ( 1 ) except Exception as e : # pylint: disable=broad-except LOG . error ( \" %s %s \" , e . __class__ . __name__ , str ( e ), exc_info = _print_tracebacks ( log_level ) ) exit_func ( 1 )","title":"main"},{"location":"reference/taskcat/#classes","text":"","title":"Classes"},{"location":"reference/taskcat/#config","text":"class Config ( sources : list , uid : uuid . UUID , project_root : pathlib . Path ) View Source class Config : def __init__ ( self , sources : list , uid : uuid . UUID , project_root : Path ): self . config = BaseConfig . from_dict ( DEFAULTS ) self . config . set_source ( \"TASKCAT_DEFAULT\" ) self . project_root = project_root self . uid = uid for source in sources : config_dict : dict = source [ \"config\" ] source_name : str = source [ \"source\" ] source_config = BaseConfig . from_dict ( config_dict ) source_config . set_source ( source_name ) self . config = BaseConfig . merge ( self . config , source_config ) @ classmethod # pylint: disable=too-many-locals def create ( cls , template_file : Optional [ Path ] = None , args : Optional [ dict ] = None , global_config_path : Path = GENERAL , project_config_path : Path = PROJECT , overrides_path : Path = OVERRIDES , env_vars : Optional [ dict ] = None , project_root : Path = PROJECT_ROOT , uid : uuid . UUID = None , ) -> \"Config\" : uid = uid if uid else uuid . uuid4 () project_source = cls . _get_project_source ( cls , project_config_path , project_root , template_file ) # general legacy_overrides ( Path ( \"~/.aws/taskcat_global_override.json\" ) . expanduser () . resolve (), global_config_path , \"global\" , ) sources = [ { \"source\" : str ( global_config_path ), \"config\" : cls . _dict_from_file ( global_config_path ), } ] # project config file if project_source : sources . append ( project_source ) # template file if isinstance ( template_file , Path ): sources . append ( { \"source\" : str ( template_file ), \"config\" : cls . _dict_from_template ( template_file ), } ) # override file legacy_overrides ( project_root / \"ci/taskcat_project_override.json\" , overrides_path , \"project\" ) if overrides_path . is_file (): overrides = BaseConfig () . to_dict () with open ( str ( overrides_path ), \"r\" , encoding = \"utf-8\" ) as file_handle : override_params = yaml . safe_load ( file_handle ) overrides [ \"project\" ][ \"parameters\" ] = override_params sources . append ({ \"source\" : str ( overrides_path ), \"config\" : overrides }) # environment variables sources . append ( { \"source\" : \"EnvoronmentVariable\" , \"config\" : cls . _dict_from_env_vars ( env_vars ), } ) # cli arguments if args : sources . append ({ \"source\" : \"CliArgument\" , \"config\" : args }) return cls ( sources = sources , uid = uid , project_root = project_root ) # pylint: disable=protected-access,inconsistent-return-statements @ staticmethod def _get_project_source ( base_cls , project_config_path , project_root , template_file ): try : return { \"source\" : str ( project_config_path ), \"config\" : base_cls . _dict_from_file ( project_config_path , fail_ok = False ), } except FileNotFoundError as e : error = e try : legacy_conf = parse_legacy_config ( project_root ) return { \"source\" : str ( project_root / \"ci/taskcat.yml\" ), \"config\" : legacy_conf . to_dict (), } except Exception as e : # pylint: disable=broad-except,redefined-outer-name LOG . debug ( str ( e ), exc_info = True ) if not template_file : # pylint: disable=raise-missing-from raise error @ staticmethod def _dict_from_file ( file_path : Path , fail_ok = True ) -> dict : config_dict = BaseConfig () . to_dict () if not file_path . is_file () and fail_ok : return config_dict try : with open ( str ( file_path ), \"r\" , encoding = \"utf-8\" ) as file_handle : config_dict = yaml . safe_load ( file_handle ) return config_dict except Exception as e : # pylint: disable=broad-except LOG . warning ( f \"failed to load config from {file_path}\" ) LOG . debug ( str ( e ), exc_info = True ) if not fail_ok : raise e return config_dict @ staticmethod def _dict_from_template ( file_path : Path ) -> dict : relative_path = str ( file_path . relative_to ( PROJECT_ROOT )) config_dict = ( BaseConfig () . from_dict ( { \"project\" : { \"template\" : relative_path }, \"tests\" : { \"default\" : {}}} ) . to_dict () ) if not file_path . is_file (): raise TaskCatException ( f \"invalid template path {file_path}\" ) try : template = Template ( str ( file_path ), template_cache = tcat_template_cache ) . template except Exception as e : LOG . warning ( f \"failed to load template from {file_path}\" ) LOG . debug ( str ( e ), exc_info = True ) raise e if not template . get ( \"Metadata\" ): return config_dict if not template [ \"Metadata\" ] . get ( \"taskcat\" ): return config_dict template_config_dict = template [ \"Metadata\" ][ \"taskcat\" ] if not template_config_dict . get ( \"project\" ): template_config_dict [ \"project\" ] = {} template_config_dict [ \"project\" ][ \"template\" ] = relative_path if not template_config_dict . get ( \"tests\" ): template_config_dict [ \"tests\" ] = { \"default\" : {}} return template_config_dict # pylint: disable=protected-access @ staticmethod def _dict_from_env_vars ( env_vars : Optional [ Union [ os . _Environ , Dict [ str , str ]]] = None ): if env_vars is None : env_vars = os . environ config_dict : Dict [ str , Dict [ str , Union [ str , bool , int ]]] = {} for key , value in env_vars . items (): if key . startswith ( \"TASKCAT_\" ): key = key [ 8 :] . lower () sub_key = None key_section = None for section in [ \"general\" , \"project\" , \"tests\" ]: if key . startswith ( section ): sub_key = key [ len ( section ) + 1 :] key_section = section if isinstance ( sub_key , str ) and isinstance ( key_section , str ): if value . isnumeric (): value = int ( value ) elif value . lower () in [ \"true\" , \"false\" ]: value = value . lower () == \"true\" if not config_dict . get ( key_section ): config_dict [ key_section ] = {} config_dict [ key_section ][ sub_key ] = value return config_dict def _get_regions ( self , region_parameter_name , test , boto3_cache : Boto3Cache = None ): if boto3_cache is None : boto3_cache = Boto3Cache () region_object = {} for region in getattr ( test , region_parameter_name , []): # TODO: comon_utils/determine_profile_for_region profile = ( test . auth . get ( region , test . auth . get ( \"default\" , \"default\" )) if test . auth else \"default\" ) region_object [ region ] = RegionObj ( name = region , account_id = boto3_cache . account_id ( profile ), partition = boto3_cache . partition ( profile ), profile = profile , _boto3_cache = boto3_cache , taskcat_id = self . uid , _role_name = test . role_name , ) return region_object def get_regions ( self , boto3_cache : Boto3Cache = None ): region_objects : Dict [ str , Dict [ str , RegionObj ]] = {} for test_name , test in self . config . tests . items (): region_objects [ test_name ] = self . _get_regions ( \"regions\" , test , boto3_cache ) return region_objects def get_artifact_regions ( self , boto3_cache : Boto3Cache = None ): region_objects : Dict [ str , Dict [ str , RegionObj ]] = {} for test_name , test in self . config . tests . items (): if test . artifact_regions is not None : region_objects [ test_name ] = self . _get_regions ( \"artifact_regions\" , test , boto3_cache ) else : region_objects [ test_name ] = self . _get_regions ( \"regions\" , test , boto3_cache ) return region_objects def get_buckets ( self , boto3_cache : Boto3Cache = None ): regions = self . get_artifact_regions ( boto3_cache ) bucket_objects : Dict [ str , S3BucketObj ] = {} bucket_mappings : Dict [ str , Dict [ str , S3BucketObj ]] = {} for test_name , test in self . config . tests . items (): bucket_mappings [ test_name ] = {} for region_name , region in regions [ test_name ] . items (): if test . s3_regional_buckets : bucket_obj = self . _create_regional_bucket_obj ( bucket_objects , region , test ) bucket_objects [ f \"{region.account_id}{region.name}\" ] = bucket_obj else : bucket_obj = self . _create_legacy_bucket_obj ( bucket_objects , region , test ) bucket_objects [ region . account_id ] = bucket_obj bucket_mappings [ test_name ][ region_name ] = bucket_obj return bucket_mappings def _create_legacy_bucket_obj ( self , bucket_objects , region , test ): new = False object_acl = ( self . config . project . s3_object_acl if self . config . project . s3_object_acl else \"private\" ) sigv4 = not self . config . project . s3_enable_sig_v2 org_id = self . config . project . org_id if not test . s3_bucket and not bucket_objects . get ( region . account_id ): name = generate_bucket_name ( self . config . project . name ) auto_generated = True new = True elif bucket_objects . get ( region . account_id ): name = bucket_objects [ region . account_id ] . name auto_generated = bucket_objects [ region . account_id ] . auto_generated else : name = test . s3_bucket auto_generated = False bucket_region = self . _get_bucket_region_for_partition ( region . partition ) bucket_obj = S3BucketObj ( name = name , region = bucket_region , account_id = region . account_id , s3_client = region . session . client ( \"s3\" , region_name = bucket_region ), auto_generated = auto_generated , object_acl = object_acl , sigv4 = sigv4 , taskcat_id = self . uid , partition = region . partition , regional_buckets = test . s3_regional_buckets , org_id = org_id , ) if new : bucket_obj . create () return bucket_obj def _create_regional_bucket_obj ( self , bucket_objects , region , test ): _bucket_obj_key = f \"{region.account_id}{region.name}\" new = False object_acl = ( self . config . project . s3_object_acl if self . config . project . s3_object_acl else \"private\" ) sigv4 = not self . config . project . s3_enable_sig_v2 org_id = self . config . project . org_id if not test . s3_bucket and not bucket_objects . get ( _bucket_obj_key ): name = generate_regional_bucket_name ( region ) auto_generated = True new = True elif bucket_objects . get ( _bucket_obj_key ): name = bucket_objects [ _bucket_obj_key ] . name auto_generated = bucket_objects [ _bucket_obj_key ] . auto_generated else : name = f \"{test.s3_bucket}-{region.name}\" auto_generated = False try : region . client ( \"s3\" ) . head_bucket ( Bucket = name ) except ClientError as e : if \"(404)\" in str ( e ): new = True else : raise bucket_obj = S3BucketObj ( name = name , region = region . name , account_id = region . account_id , s3_client = region . session . client ( \"s3\" , region_name = region . name ), auto_generated = auto_generated , object_acl = object_acl , sigv4 = sigv4 , taskcat_id = self . uid , partition = region . partition , regional_buckets = test . s3_regional_buckets , org_id = org_id , ) if new : bucket_obj . create () return bucket_obj @ staticmethod def _get_bucket_region_for_partition ( partition ): region = \"us-east-1\" if partition == \"aws-us-gov\" : region = \"us-gov-east-1\" elif partition == \"aws-cn\" : region = \"cn-north-1\" return region def get_rendered_parameters ( self , bucket_objects , region_objects , template_objects ): parameters = {} template_params = self . get_params_from_templates ( template_objects ) for test_name , test in self . config . tests . items (): parameters [ test_name ] = {} for region_name in test . regions : region_params = template_params [ test_name ] . copy () for param_key , param_value in test . parameters . items (): if param_key in region_params : region_params [ param_key ] = param_value region = region_objects [ test_name ][ region_name ] s3bucket = bucket_objects [ test_name ][ region_name ] parameters [ test_name ][ region_name ] = ParamGen ( self . project_root , region_params , s3bucket . name , region . name , region . client , self . config . project . name , test_name , test . az_blacklist , ) . results return parameters @ staticmethod def get_params_from_templates ( template_objects ): parameters = {} for test_name , template in template_objects . items (): parameters [ test_name ] = template . parameters () return parameters def get_templates ( self ): templates = {} for test_name , test in self . config . tests . items (): templates [ test_name ] = Template ( template_path = self . project_root / test . template , project_root = self . project_root , s3_key_prefix = f \"{self.config.project.name}/\" , template_cache = tcat_template_cache , ) return templates def get_tests ( self , templates , regions , buckets , parameters ): tests = {} for test_name , test in self . config . tests . items (): region_list = [] artifact_region_list = [] tag_list = [] if test . tags : for tag_key , tag_value in test . tags . items (): tag_list . append ( Tag ({ \"Key\" : tag_key , \"Value\" : tag_value })) for region_obj in regions [ test_name ] . values (): region_list . append ( TestRegion . from_region_obj ( region_obj , buckets [ test_name ][ region_obj . name ], parameters [ test_name ][ region_obj . name ], ) ) tests [ test_name ] = TestObj ( name = test_name , template_path = self . project_root / test . template , template = templates [ test_name ], project_root = self . project_root , regions = region_list , artifact_regions = artifact_region_list , tags = tag_list , uid = self . uid , _project_name = self . config . project . name , _shorten_stack_name = self . config . project . shorten_stack_name , _stack_name = test . stack_name , _stack_name_prefix = test . stack_name_prefix , _stack_name_suffix = test . stack_name_suffix , ) return tests","title":"Config"},{"location":"reference/taskcat/#static-methods","text":"","title":"Static methods"},{"location":"reference/taskcat/#create","text":"def create ( template_file : Union [ pathlib . Path , NoneType ] = None , args : Union [ dict , NoneType ] = None , global_config_path : pathlib . Path = PosixPath ( '/Users/tonynv/.taskcat.yml' ), project_config_path : pathlib . Path = PosixPath ( '/Users/tonynv/work/github/tonynv/taskcat/.taskcat.yml' ), overrides_path : pathlib . Path = PosixPath ( '/Users/tonynv/work/github/tonynv/taskcat/.taskcat_overrides.yml' ), env_vars : Union [ dict , NoneType ] = None , project_root : pathlib . Path = PosixPath ( '/Users/tonynv/work/github/tonynv/taskcat' ), uid : uuid . UUID = None ) -> 'Config' View Source @ classmethod # pylint: disable=too-many-locals def create ( cls , template_file : Optional [ Path ] = None , args : Optional [ dict ] = None , global_config_path : Path = GENERAL , project_config_path : Path = PROJECT , overrides_path : Path = OVERRIDES , env_vars : Optional [ dict ] = None , project_root : Path = PROJECT_ROOT , uid : uuid . UUID = None , ) -> \"Config\" : uid = uid if uid else uuid . uuid4 () project_source = cls . _get_project_source ( cls , project_config_path , project_root , template_file ) # general legacy_overrides ( Path ( \"~/.aws/taskcat_global_override.json\" ) . expanduser () . resolve (), global_config_path , \"global\" , ) sources = [ { \"source\" : str ( global_config_path ), \"config\" : cls . _dict_from_file ( global_config_path ), } ] # project config file if project_source : sources . append ( project_source ) # template file if isinstance ( template_file , Path ): sources . append ( { \"source\" : str ( template_file ), \"config\" : cls . _dict_from_template ( template_file ), } ) # override file legacy_overrides ( project_root / \"ci/taskcat_project_override.json\" , overrides_path , \"project\" ) if overrides_path . is_file (): overrides = BaseConfig () . to_dict () with open ( str ( overrides_path ), \"r\" , encoding = \"utf-8\" ) as file_handle : override_params = yaml . safe_load ( file_handle ) overrides [ \"project\" ][ \"parameters\" ] = override_params sources . append ({ \"source\" : str ( overrides_path ), \"config\" : overrides }) # environment variables sources . append ( { \"source\" : \"EnvoronmentVariable\" , \"config\" : cls . _dict_from_env_vars ( env_vars ), } ) # cli arguments if args : sources . append ({ \"source\" : \"CliArgument\" , \"config\" : args }) return cls ( sources = sources , uid = uid , project_root = project_root )","title":"create"},{"location":"reference/taskcat/#get_params_from_templates","text":"def get_params_from_templates ( template_objects ) View Source @staticmethod def get_params_from_templates ( template_objects ) : parameters = {} for test_name , template in template_objects . items () : parameters [ test_name ] = template . parameters () return parameters","title":"get_params_from_templates"},{"location":"reference/taskcat/#methods","text":"","title":"Methods"},{"location":"reference/taskcat/#get_artifact_regions","text":"def get_artifact_regions ( self , boto3_cache : taskcat . _client_factory . Boto3Cache = None ) View Source def get_artifact_regions ( self , boto3_cache : Boto3Cache = None ) : region_objects : Dict [ str, Dict[str, RegionObj ] ] = {} for test_name , test in self . config . tests . items () : if test . artifact_regions is not None : region_objects [ test_name ] = self . _get_regions ( \"artifact_regions\" , test , boto3_cache ) else : region_objects [ test_name ] = self . _get_regions ( \"regions\" , test , boto3_cache ) return region_objects","title":"get_artifact_regions"},{"location":"reference/taskcat/#get_buckets","text":"def get_buckets ( self , boto3_cache : taskcat . _client_factory . Boto3Cache = None ) View Source def get_buckets ( self , boto3_cache : Boto3Cache = None ) : regions = self . get_artifact_regions ( boto3_cache ) bucket_objects : Dict [ str, S3BucketObj ] = {} bucket_mappings : Dict [ str, Dict[str, S3BucketObj ] ] = {} for test_name , test in self . config . tests . items () : bucket_mappings [ test_name ] = {} for region_name , region in regions [ test_name ] . items () : if test . s3_regional_buckets : bucket_obj = self . _create_regional_bucket_obj ( bucket_objects , region , test ) bucket_objects [ f\"{region.account_id}{region.name}\" ] = bucket_obj else : bucket_obj = self . _create_legacy_bucket_obj ( bucket_objects , region , test ) bucket_objects [ region.account_id ] = bucket_obj bucket_mappings [ test_name ][ region_name ] = bucket_obj return bucket_mappings","title":"get_buckets"},{"location":"reference/taskcat/#get_regions","text":"def get_regions ( self , boto3_cache : taskcat . _client_factory . Boto3Cache = None ) View Source def get_regions ( self , boto3_cache : Boto3Cache = None ) : region_objects : Dict [ str, Dict[str, RegionObj ] ] = {} for test_name , test in self . config . tests . items () : region_objects [ test_name ] = self . _get_regions ( \"regions\" , test , boto3_cache ) return region_objects","title":"get_regions"},{"location":"reference/taskcat/#get_rendered_parameters","text":"def get_rendered_parameters ( self , bucket_objects , region_objects , template_objects ) View Source def get_rendered_parameters ( self , bucket_objects , region_objects , template_objects ) : parameters = {} template_params = self . get_params_from_templates ( template_objects ) for test_name , test in self . config . tests . items () : parameters [ test_name ] = {} for region_name in test . regions : region_params = template_params [ test_name ] . copy () for param_key , param_value in test . parameters . items () : if param_key in region_params : region_params [ param_key ] = param_value region = region_objects [ test_name ][ region_name ] s3bucket = bucket_objects [ test_name ][ region_name ] parameters [ test_name ][ region_name ] = ParamGen ( self . project_root , region_params , s3bucket . name , region . name , region . client , self . config . project . name , test_name , test . az_blacklist , ). results return parameters","title":"get_rendered_parameters"},{"location":"reference/taskcat/#get_templates","text":"def get_templates ( self ) View Source def get_templates ( self ) : templates = {} for test_name , test in self . config . tests . items () : templates [ test_name ] = Template ( template_path = self . project_root / test . template , project_root = self . project_root , s3_key_prefix = f \"{self.config.project.name}/\" , template_cache = tcat_template_cache , ) return templates","title":"get_templates"},{"location":"reference/taskcat/#get_tests","text":"def get_tests ( self , templates , regions , buckets , parameters ) View Source def get_tests ( self , templates , regions , buckets , parameters ) : tests = {} for test_name , test in self . config . tests . items () : region_list = [] artifact_region_list = [] tag_list = [] if test . tags : for tag_key , tag_value in test . tags . items () : tag_list . append ( Tag ( { \"Key\" : tag_key , \"Value\" : tag_value } )) for region_obj in regions [ test_name ] . values () : region_list . append ( TestRegion . from_region_obj ( region_obj , buckets [ test_name ][ region_obj.name ] , parameters [ test_name ][ region_obj.name ] , ) ) tests [ test_name ] = TestObj ( name = test_name , template_path = self . project_root / test . template , template = templates [ test_name ] , project_root = self . project_root , regions = region_list , artifact_regions = artifact_region_list , tags = tag_list , uid = self . uid , _project_name = self . config . project . name , _shorten_stack_name = self . config . project . shorten_stack_name , _stack_name = test . stack_name , _stack_name_prefix = test . stack_name_prefix , _stack_name_suffix = test . stack_name_suffix , ) return tests","title":"get_tests"},{"location":"reference/taskcat/#stack","text":"class Stack ( region : taskcat . _dataclasses . TestRegion , stack_id : str , template : taskcat . _cfn . template . Template , test_name , uuid : uuid . UUID = None ) View Source class Stack : # pylint: disable=too-many-instance-attributes REMOTE_TEMPLATE_PATH = Path ( \".taskcat/.remote_templates\" ) def __init__ ( self , region : TestRegion , stack_id : str , template : Template , test_name , uuid : UUID = None , ): uuid = uuid if uuid else uuid4 () self . test_name : str = test_name self . uuid : UUID = uuid self . id : str = stack_id self . template : Template = template self . name : str = self . _get_name () self . region : TestRegion = region self . region_name = region . name self . client : boto3 . client = region . client ( \"cloudformation\" ) self . completion_time : timedelta = timedelta ( 0 ) self . role_arn = region . role_arn # properties from additional cfn api calls self . _events : Events = Events () self . _resources : Resources = Resources () self . _children : Stacks = Stacks () # properties from describe_stacks response self . change_set_id : str = \"\" self . parameters : List [ Parameter ] = [] self . creation_time : datetime = datetime . fromtimestamp ( 0 ) self . deletion_time : datetime = datetime . fromtimestamp ( 0 ) self . _status : str = \"\" self . status_reason : str = \"\" self . disable_rollback : bool = False self . timeout_in_minutes : int = 0 self . capabilities : List [ str ] = [] self . outputs : List [ Output ] = [] self . tags : List [ Tag ] = [] self . parent_id : str = \"\" self . root_id : str = \"\" self . _launch_succeeded : bool = False self . _auto_refresh_interval : timedelta = timedelta ( seconds = 60 ) self . _last_event_refresh : datetime = datetime . fromtimestamp ( 0 ) self . _last_resource_refresh : datetime = datetime . fromtimestamp ( 0 ) self . _last_child_refresh : datetime = datetime . fromtimestamp ( 0 ) self . _timer = Timer ( self . _auto_refresh_interval . total_seconds (), self . refresh ) self . _timer . start () def __str__ ( self ): return self . id def __repr__ ( self ): return \"<Stack object {} at {}>\" . format ( self . name , hex ( id ( self ))) def _get_region ( self ) -> str : return self . id . split ( \":\" )[ 3 ] def _get_name ( self ) -> str : return self . id . split ( \":\" )[ 5 ] . split ( \"/\" )[ 1 ] def _auto_refresh ( self , last_refresh ): if datetime . now () - last_refresh > self . _auto_refresh_interval : return True return False @ property def status ( self ): if self . _status in StackStatus . COMPLETE : if not self . launch_succeeded : self . _status = \"OUT_OF_ORDER_EVENT\" self . status_reason = ( \"COMPLETE event not detected. \" + \"Potential out-of-band action against the stack.\" ) return self . _status @ status . setter def status ( self , status ): _complete = StackStatus . COMPLETE . copy () del _complete [ _complete . index ( \"DELETE_COMPLETE\" )] self . _status = status if status in StackStatus . FAILED : self . _launch_succeeded = False return if status in _complete : self . _launch_succeeded = True return return @ property def launch_succeeded ( self ): return self . _launch_succeeded @ classmethod def create ( cls , region : TestRegion , stack_name : str , template : Template , tags : List [ Tag ] = None , disable_rollback : bool = True , test_name : str = \"\" , uuid : UUID = None , ) -> \"Stack\" : parameters = cls . _cfn_format_parameters ( region . parameters ) uuid = uuid if uuid else uuid4 () cfn_client = region . client ( \"cloudformation\" ) tags = [ t . dump () for t in tags ] if tags else [] template = Template ( template_path = template . template_path , project_root = template . project_root , s3_key_prefix = template . s3_key_prefix , url = s3_url_maker ( region . s3_bucket . name , template . s3_key , region . client ( \"s3\" ), region . s3_bucket . auto_generated , ), template_cache = tcat_template_cache , ) create_options = { \"StackName\" : stack_name , \"TemplateURL\" : template . url , \"Parameters\" : parameters , \"DisableRollback\" : disable_rollback , \"Tags\" : tags , \"Capabilities\" : Capabilities . ALL , } if region . role_arn : create_options [ \"RoleARN\" ] = region . role_arn stack_id = cfn_client . create_stack ( ** create_options )[ \"StackId\" ] stack = cls ( region , stack_id , template , test_name , uuid ) # fetch property values from cfn stack . refresh () return stack @ staticmethod def _cfn_format_parameters ( parameters ): return [{ \"ParameterKey\" : k , \"ParameterValue\" : v } for k , v in parameters . items ()] @ classmethod def _import_child ( # pylint: disable=too-many-locals cls , stack_properties : dict , parent_stack : \"Stack\" ) -> Optional [ \"Stack\" ]: try : url = \"\" for event in parent_stack . events (): if ( event . physical_id == stack_properties [ \"StackId\" ] and event . properties ): url = event . properties [ \"TemplateURL\" ] if url . startswith ( parent_stack . template . url_prefix ()): # Template is part of the project, discovering path relative_path = url . replace ( parent_stack . template . url_prefix (), \"\" ) . lstrip ( \"/\" ) absolute_path = parent_stack . template . project_root / relative_path if not absolute_path . is_file (): # try with the base folder stripped off relative_path2 = Path ( relative_path ) relative_path2 = relative_path2 . relative_to ( * relative_path2 . parts [: 1 ] ) absolute_path = parent_stack . template . project_root / relative_path2 if not absolute_path . is_file (): LOG . warning ( f \"Failed to find template for child stack \" f \"{stack_properties['StackId']}. tried \" f \"{parent_stack.template.project_root / relative_path}\" f \" and {absolute_path}\" ) return None else : # Assuming template is remote to project and downloading it cfn_client = parent_stack . client tempate_body = cfn_client . get_template ( StackName = stack_properties [ \"StackId\" ] )[ \"TemplateBody\" ] path = parent_stack . template . project_root / Stack . REMOTE_TEMPLATE_PATH os . makedirs ( path , exist_ok = True ) fname = ( \"\" . join ( random . choice ( string . ascii_lowercase ) # nosec for _ in range ( 16 ) ) + \".template\" ) absolute_path = path / fname if not isinstance ( tempate_body , str ): tempate_body = ordered_dump ( tempate_body , dumper = yaml . SafeDumper ) if not absolute_path . exists (): with open ( absolute_path , \"w\" , encoding = \"utf-8\" ) as fh : fh . write ( tempate_body ) template = Template ( template_path = str ( absolute_path ), project_root = parent_stack . template . project_root , url = url , template_cache = tcat_template_cache , ) stack = cls ( parent_stack . region , stack_properties [ \"StackId\" ], template , parent_stack . name , parent_stack . uuid , ) stack . set_stack_properties ( stack_properties ) except Exception as e : # pylint: disable=broad-except LOG . warning ( f \"Failed to import child stack: {str(e)}\" ) LOG . debug ( \"traceback:\" , exc_info = True ) return None return stack @ classmethod def import_existing ( cls , stack_properties : dict , template : Template , region : TestRegion , test_name : str , uid : UUID , ) -> \"Stack\" : stack = cls ( region , stack_properties [ \"StackId\" ], template , test_name , uid ) stack . set_stack_properties ( stack_properties ) return stack def refresh ( self , properties : bool = True , events : bool = False , resources : bool = False , children : bool = False , ) -> None : if properties : self . set_stack_properties () if events : self . _fetch_stack_events () self . _last_event_refresh = datetime . now () if resources : self . _fetch_stack_resources () self . _last_resource_refresh = datetime . now () if children : self . _fetch_children () self . _last_child_refresh = datetime . now () def set_stack_properties ( self , stack_properties : Optional [ dict ] = None ) -> None : # TODO: get time to complete for complete stacks and % complete props : dict = stack_properties if stack_properties else {} self . _timer . cancel () if not props : describe_stacks = self . client . describe_stacks props = describe_stacks ( StackName = self . id )[ \"Stacks\" ][ 0 ] iterable_props : List [ Tuple [ str , Callable ]] = [ ( \"Parameters\" , Parameter ), ( \"Outputs\" , Output ), ( \"Tags\" , Tag ), ] for prop_name , prop_class in iterable_props : for item in props . get ( prop_name , []): item = prop_class ( item ) self . _merge_props ( getattr ( self , prop_name . lower ()), item ) for key , value in props . items (): if key in [ p [ 0 ] for p in iterable_props ]: # noqa: C412 continue key = pascal_to_snake ( key ) . replace ( \"stack_\" , \"\" ) setattr ( self , key , value ) if self . status in StackStatus . IN_PROGRESS : self . _timer = Timer ( self . _auto_refresh_interval . total_seconds (), self . refresh ) self . _timer . start () @ staticmethod def _merge_props ( existing_props , new ): added = False for existing_id , prop in enumerate ( existing_props ): if prop . key == new . key : existing_props [ existing_id ] = new added = True if not added : existing_props . append ( new ) def events ( self , refresh : bool = False , include_generic : bool = True ) -> Events : if refresh or not self . _events or self . _auto_refresh ( self . _last_event_refresh ): self . _fetch_stack_events () events = self . _events if not include_generic : events = Events ([ event for event in events if not self . _is_generic ( event )]) return events @ staticmethod def _is_generic ( event : Event ) -> bool : generic = False for regex in GENERIC_ERROR_PATTERNS : if re . search ( regex , event . status_reason ): generic = True return generic def _fetch_stack_events ( self ) -> None : self . _last_event_refresh = datetime . now () events = Events () for page in self . client . get_paginator ( \"describe_stack_events\" ) . paginate ( StackName = self . id ): for event in page [ \"StackEvents\" ]: events . append ( Event ( event )) self . _events = events def resources ( self , refresh : bool = False ) -> Resources : if ( refresh or not self . _resources or self . _auto_refresh ( self . _last_resource_refresh ) ): self . _fetch_stack_resources () return self . _resources def _fetch_stack_resources ( self ) -> None : self . _last_resource_refresh = datetime . now () resources = Resources () for page in self . client . get_paginator ( \"list_stack_resources\" ) . paginate ( StackName = self . id ): for resource in page [ \"StackResourceSummaries\" ]: resources . append ( Resource ( self . id , resource , self . test_name , self . uuid )) self . _resources = resources @ staticmethod def delete ( client , stack_id ) -> None : client . delete_stack ( StackName = stack_id ) LOG . info ( f \"Deleting stack: {stack_id}\" ) def update ( self , * args , ** kwargs ): raise NotImplementedError ( \"Stack updates not implemented\" ) def _fetch_children ( self ) -> None : self . _last_child_refresh = datetime . now () for page in self . client . get_paginator ( \"describe_stacks\" ) . paginate (): for stack in page [ \"Stacks\" ]: if self . _children . filter ( id = stack [ \"StackId\" ]): continue if \"ParentId\" in stack . keys (): if self . id == stack [ \"ParentId\" ]: stack_obj = Stack . _import_child ( stack , self ) if stack_obj : self . _children . append ( stack_obj ) def children ( self , refresh = False ) -> Stacks : if ( refresh or not self . _children or self . _auto_refresh ( self . _last_child_refresh ) ): self . _fetch_children () return self . _children def descendants ( self , refresh = False ) -> Stacks : if refresh or not self . _children : self . _fetch_children () def recurse ( stack : Stack , descendants : Stacks = None ) -> Stacks : descendants = descendants if descendants else Stacks () if stack . children ( refresh = refresh ): descendants += stack . children () for child in stack . children (): descendants = recurse ( child , descendants ) return descendants return recurse ( self ) def error_events ( self , recurse : bool = True , include_generic : bool = False , refresh = False ) -> Events : errors = Events () stacks = Stacks ([ self ]) if recurse : stacks += self . descendants () for stack in stacks : for status in StackStatus . FAILED : errors += stack . events ( refresh = refresh , include_generic = include_generic ) . filter ({ \"status\" : status }) return errors","title":"Stack"},{"location":"reference/taskcat/#class-variables","text":"REMOTE_TEMPLATE_PATH","title":"Class variables"},{"location":"reference/taskcat/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/taskcat/#create_1","text":"def create ( region : taskcat . _dataclasses . TestRegion , stack_name : str , template : taskcat . _cfn . template . Template , tags : List [ taskcat . _dataclasses . Tag ] = None , disable_rollback : bool = True , test_name : str = '' , uuid : uuid . UUID = None ) -> 'Stack' View Source @classmethod def create ( cls , region : TestRegion , stack_name : str , template : Template , tags : List [ Tag ] = None , disable_rollback : bool = True , test_name : str = \"\" , uuid : UUID = None , ) -> \"Stack\" : parameters = cls . _cfn_format_parameters ( region . parameters ) uuid = uuid if uuid else uuid4 () cfn_client = region . client ( \"cloudformation\" ) tags = [ t.dump() for t in tags ] if tags else [] template = Template ( template_path = template . template_path , project_root = template . project_root , s3_key_prefix = template . s3_key_prefix , url = s3_url_maker ( region . s3_bucket . name , template . s3_key , region . client ( \"s3\" ), region . s3_bucket . auto_generated , ), template_cache = tcat_template_cache , ) create_options = { \"StackName\" : stack_name , \"TemplateURL\" : template . url , \"Parameters\" : parameters , \"DisableRollback\" : disable_rollback , \"Tags\" : tags , \"Capabilities\" : Capabilities . ALL , } if region . role_arn : create_options [ \"RoleARN\" ] = region . role_arn stack_id = cfn_client . create_stack ( ** create_options ) [ \"StackId\" ] stack = cls ( region , stack_id , template , test_name , uuid ) # fetch property values from cfn stack . refresh () return stack","title":"create"},{"location":"reference/taskcat/#delete","text":"def delete ( client , stack_id ) -> None View Source @staticmethod def delete ( client , stack_id ) -> None : client . delete_stack ( StackName = stack_id ) LOG . info ( f \"Deleting stack: {stack_id}\" )","title":"delete"},{"location":"reference/taskcat/#import_existing","text":"def import_existing ( stack_properties : dict , template : taskcat . _cfn . template . Template , region : taskcat . _dataclasses . TestRegion , test_name : str , uid : uuid . UUID ) -> 'Stack' View Source @classmethod def import_existing ( cls , stack_properties : dict , template : Template , region : TestRegion , test_name : str , uid : UUID , ) -> \"Stack\" : stack = cls ( region , stack_properties [ \"StackId\" ] , template , test_name , uid ) stack . set_stack_properties ( stack_properties ) return stack","title":"import_existing"},{"location":"reference/taskcat/#instance-variables","text":"launch_succeeded status","title":"Instance variables"},{"location":"reference/taskcat/#methods_1","text":"","title":"Methods"},{"location":"reference/taskcat/#children","text":"def children ( self , refresh = False ) -> taskcat . _cfn . stack . Stacks View Source def children ( self , refresh = False ) -> Stacks : if ( refresh or not self . _children or self . _auto_refresh ( self . _last_child_refresh ) ) : self . _fetch_children () return self . _children","title":"children"},{"location":"reference/taskcat/#descendants","text":"def descendants ( self , refresh = False ) -> taskcat . _cfn . stack . Stacks View Source def descendants ( self , refresh = False ) -> Stacks : if refresh or not self . _children : self . _fetch_children () def recurse ( stack : Stack , descendants : Stacks = None ) -> Stacks : descendants = descendants if descendants else Stacks () if stack . children ( refresh = refresh ) : descendants += stack . children () for child in stack . children () : descendants = recurse ( child , descendants ) return descendants return recurse ( self )","title":"descendants"},{"location":"reference/taskcat/#error_events","text":"def error_events ( self , recurse : bool = True , include_generic : bool = False , refresh = False ) -> taskcat . _cfn . stack . Events View Source def error_events ( self , recurse : bool = True , include_generic : bool = False , refresh = False ) -> Events : errors = Events () stacks = Stacks ( [ self ] ) if recurse : stacks += self . descendants () for stack in stacks : for status in StackStatus . FAILED : errors += stack . events ( refresh = refresh , include_generic = include_generic ). filter ( { \"status\" : status } ) return errors","title":"error_events"},{"location":"reference/taskcat/#events","text":"def events ( self , refresh : bool = False , include_generic : bool = True ) -> taskcat . _cfn . stack . Events View Source def events ( self , refresh : bool = False , include_generic : bool = True ) -> Events : if refresh or not self . _events or self . _auto_refresh ( self . _last_event_refresh ) : self . _fetch_stack_events () events = self . _events if not include_generic : events = Events ([ event for event in events if not self . _is_generic ( event )]) return events","title":"events"},{"location":"reference/taskcat/#refresh","text":"def refresh ( self , properties : bool = True , events : bool = False , resources : bool = False , children : bool = False ) -> None View Source def refresh ( self , properties : bool = True , events : bool = False , resources : bool = False , children : bool = False , ) -> None : if properties : self . set_stack_properties () if events : self . _fetch_stack_events () self . _last_event_refresh = datetime . now () if resources : self . _fetch_stack_resources () self . _last_resource_refresh = datetime . now () if children : self . _fetch_children () self . _last_child_refresh = datetime . now ()","title":"refresh"},{"location":"reference/taskcat/#resources","text":"def resources ( self , refresh : bool = False ) -> taskcat . _cfn . stack . Resources View Source def resources ( self , refresh : bool = False ) -> Resources : if ( refresh or not self . _resources or self . _auto_refresh ( self . _last_resource_refresh ) ) : self . _fetch_stack_resources () return self . _resources","title":"resources"},{"location":"reference/taskcat/#set_stack_properties","text":"def set_stack_properties ( self , stack_properties : Union [ dict , NoneType ] = None ) -> None View Source def set_stack_properties ( self , stack_properties : Optional [ dict ] = None ) -> None : # TODO : get time to complete for complete stacks and % complete props : dict = stack_properties if stack_properties else {} self . _timer . cancel () if not props : describe_stacks = self . client . describe_stacks props = describe_stacks ( StackName = self . id ) [ \"Stacks\" ][ 0 ] iterable_props : List [ Tuple[str, Callable ] ] = [ (\"Parameters\", Parameter), (\"Outputs\", Output), (\"Tags\", Tag), ] for prop_name , prop_class in iterable_props : for item in props . get ( prop_name , [] ) : item = prop_class ( item ) self . _merge_props ( getattr ( self , prop_name . lower ()), item ) for key , value in props . items () : if key in [ p[0 ] for p in iterable_props ]: # noqa : C412 continue key = pascal_to_snake ( key ). replace ( \"stack_\" , \"\" ) setattr ( self , key , value ) if self . status in StackStatus . IN_PROGRESS : self . _timer = Timer ( self . _auto_refresh_interval . total_seconds (), self . refresh ) self . _timer . start ()","title":"set_stack_properties"},{"location":"reference/taskcat/#update","text":"def update ( self , * args , ** kwargs ) View Source def update(self, *args, **kwargs): raise NotImplementedError(\"Stack updates not implemented\")","title":"update"},{"location":"reference/taskcat/#template","text":"class Template ( template_path : Union [ str , pathlib . Path ], project_root : Union [ str , pathlib . Path ] = '' , url : str = '' , s3_key_prefix : str = '' , template_cache : taskcat . _cfn . template . TemplateCache = < taskcat . _cfn . template . TemplateCache object at 0x10e045490 > ) View Source class Template : def __ init__ ( self , template_path : Union [ str , Path ], project_root : Union [ str , Path ] = \"\" , url : str = \"\" , s3_key_prefix : str = \"\" , template_cache : TemplateCache = tcat_template_cache , ) : self . template_cache = template_cache self . template_path : Path = Path ( template_path ). expanduser (). resolve () self . template = self . template_cache . get ( str ( self . template_path )) with open ( template_path , \"r\" , encoding= \"utf-8\" ) as file_handle : self . raw_template = file_handle . read () project_root = ( project_root if project_root else self . template_path . parent . parent ) self . project_root = Path ( project_root ). expanduser (). resolve () self . url = url self . _ s3_key_prefix = s3_key_prefix self . children : List [ Template ] = [] self . _ find_children () def __ str__ ( self ) : return str ( self . template ) def __ repr__ ( self ) : return f \"<Template {self.template_path} at {hex(id(self))}>\" @property def s3_key ( self ) : suffix = str ( self . template_path . relative_to ( self . project_root ). as_posix ()) return self . _ s3_key_prefix + suffix @property def s3_key_prefix ( self ) : return self . _ s3_key_prefix @property def linesplit ( self ) : return self . raw_template . split ( \"\\n\" ) def write ( self ) : \"\"\"writes raw_template back to file, and reloads decoded template, useful if the template has been modified\"\"\" with open ( str ( self . template_path ), \"w\" , encoding= \"utf-8\" ) as file_handle : file_handle . write ( self . raw_template ) self . template = cfnlint . decode . cfn_yaml . load ( self . template_path ) self . _ find_children () def _ template_url_to_path ( self , template_url , template_mappings = None , ) : try : helper = StackURLHelper ( template_mappings = template_mappings , template_parameters = self . template . get ( \"Parameters\" ), ) urls = helper . template_url_to_path ( current_template_path = self . template_path , template_url = template_url ) if len ( urls ) > 0 : return urls [ 0 ] except Exception as e : # pylint : disable = broad - except LOG . debug ( \"Traceback:\" , exc_info = True ) LOG . error ( \"TemplateURL parsing error: %s \" % str(e)) LOG . warning ( \"Failed to discover path for %s, path %s does not exist\" , template_url , None , ) return \"\" def _ get_relative_url ( self , path : str ) -> str : suffix = str ( path ). replace ( str ( self . project_root ), \"\" ) url = self . url_prefix () + suffix return url def url_prefix ( self ) -> str : if not self . url : return \"\" regionless_url = re . sub ( r \" \\.s3\\. (. * ) \\.amazonaws\\.com \", \" . s3 . amazonaws . com \", self.url, ) suffix = str(self.template_path).replace(str(self.project_root), \"\") suffix_length = len(suffix.lstrip(\" / \").split(\" / \")) url_prefix = \" / \".join(regionless_url.split(\" / \")[0:-suffix_length]) return url_prefix def _find_children(self) -> None: # noqa: C901 children = set() if \" Resources \" not in self.template: raise TaskCatException( f\" did not receive a val id template : { self . template_path } does not \" f\" have a Resources section \" ) for resource in self.template[\" Resources \"].keys(): resource = self.template[\" Resources \"][resource] if resource[\" Type \"] == \" AWS :: CloudFormation :: Stack \": child_name = self._template_url_to_path( template_url=resource[\" Properties \"][\" TemplateURL \"], ) # print(child_name) if child_name: # for child_url in child_name: children.add(child_name) for child in children: child_template_instance = None for descendent in self.descendents: if str(descendent.template_path) == str(child): child_template_instance = descendent if not child_template_instance: try: child_template_instance = Template( child, self.project_root, self._get_relative_url(child), self._s3_key_prefix, tcat_template_cache, ) except Exception: # pylint: disable=broad-except LOG.debug(\" Traceback : \", exc_info=True) LOG.error(f\" Failed to add child template { child } \") if isinstance(child_template_instance, Template): self.children.append(child_template_instance) @property def descendents(self) -> List[\" Template \"]: desc_map = {} def recurse(template): for child in template.children: desc_map[str(child.template_path)] = child recurse(child) recurse(self) return list(desc_map.values()) def parameters( self, ) -> Dict[str, Union[None, str, int, bool, List[Union[int, str]]]]: parameters = {} for param_key, param in self.template.get(\" Parameters \", {}).items(): parameters[param_key] = param.get(\" Default \" ) return parameters","title":"Template"},{"location":"reference/taskcat/#instance-variables_1","text":"descendents linesplit s3_key s3_key_prefix","title":"Instance variables"},{"location":"reference/taskcat/#methods_2","text":"","title":"Methods"},{"location":"reference/taskcat/#parameters","text":"def parameters ( self ) -> Dict [ str , Union [ NoneType , str , int , bool , List [ Union [ str , int ]]]] View Source def parameters ( self , ) -> Dict [ str, Union[None, str, int, bool, List[Union[int, str ] ]]]: parameters = {} for param_key , param in self . template . get ( \"Parameters\" , {} ). items () : parameters [ param_key ] = param . get ( \"Default\" ) return parameters","title":"parameters"},{"location":"reference/taskcat/#url_prefix","text":"def url_prefix ( self ) -> str View Source def url_prefix ( self ) -> str : if not self . url : return \"\" regionless_url = re . sub ( r \" \\.s3\\. (. * ) \\.amazonaws\\.com \", \" . s3 . amazonaws . com \", self.url, ) suffix = str(self.template_path).replace(str(self.project_root), \"\") suffix_length = len(suffix.lstrip(\" / \").split(\" / \")) url_prefix = \" / \".join(regionless_url.split(\" / \" )[ 0 :- suffix_length ]) return url_prefix","title":"url_prefix"},{"location":"reference/taskcat/#write","text":"def write ( self ) writes raw_template back to file, and reloads decoded template, useful if the template has been modified View Source def write ( self ): \"\"\"writes raw_template back to file, and reloads decoded template, useful if the template has been modified\"\"\" with open ( str ( self . template_path ), \"w\" , encoding = \"utf-8\" ) as file_handle : file_handle . write ( self . raw_template ) self . template = cfnlint . decode . cfn_yaml . load ( self . template_path ) self . _find_children ()","title":"write"},{"location":"reference/taskcat/exceptions/","text":"Module taskcat.exceptions None None View Source class TaskCatException ( Exception ): \"\"\"Raised when taskcat experiences a fatal error\"\"\" class InvalidActionError ( TaskCatException ): \"\"\"Exception raised for error when invalid action is supplied Attributes: expression -- input expression in which the error occurred \"\"\" def __init__ ( self , expression ): self . expression = expression super (). __init__ () Classes InvalidActionError class InvalidActionError ( expression ) Exception raised for error when invalid action is supplied Attributes: expression -- input expression in which the error occurred View Source class InvalidActionError ( TaskCatException ): \"\"\"Exception raised for error when invalid action is supplied Attributes: expression -- input expression in which the error occurred \"\"\" def __init__ ( self , expression ): self . expression = expression super (). __init__ () Ancestors (in MRO) taskcat.exceptions.TaskCatException builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. TaskCatException class TaskCatException ( / , * args , ** kwargs ) View Source class TaskCatException ( Exception ): \"\"\"Raised when taskcat experiences a fatal error\"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Descendants taskcat.exceptions.InvalidActionError taskcat._s3_stage.S3BucketCreatorException taskcat._amiupdater.AMIUpdaterFatalException taskcat._amiupdater.AMIUpdaterCommitNeededException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Exceptions"},{"location":"reference/taskcat/exceptions/#module-taskcatexceptions","text":"None None View Source class TaskCatException ( Exception ): \"\"\"Raised when taskcat experiences a fatal error\"\"\" class InvalidActionError ( TaskCatException ): \"\"\"Exception raised for error when invalid action is supplied Attributes: expression -- input expression in which the error occurred \"\"\" def __init__ ( self , expression ): self . expression = expression super (). __init__ ()","title":"Module taskcat.exceptions"},{"location":"reference/taskcat/exceptions/#classes","text":"","title":"Classes"},{"location":"reference/taskcat/exceptions/#invalidactionerror","text":"class InvalidActionError ( expression ) Exception raised for error when invalid action is supplied Attributes: expression -- input expression in which the error occurred View Source class InvalidActionError ( TaskCatException ): \"\"\"Exception raised for error when invalid action is supplied Attributes: expression -- input expression in which the error occurred \"\"\" def __init__ ( self , expression ): self . expression = expression super (). __init__ ()","title":"InvalidActionError"},{"location":"reference/taskcat/exceptions/#ancestors-in-mro","text":"taskcat.exceptions.TaskCatException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/taskcat/exceptions/#class-variables","text":"args","title":"Class variables"},{"location":"reference/taskcat/exceptions/#methods","text":"","title":"Methods"},{"location":"reference/taskcat/exceptions/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/taskcat/exceptions/#taskcatexception","text":"class TaskCatException ( / , * args , ** kwargs ) View Source class TaskCatException ( Exception ): \"\"\"Raised when taskcat experiences a fatal error\"\"\"","title":"TaskCatException"},{"location":"reference/taskcat/exceptions/#ancestors-in-mro_1","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/taskcat/exceptions/#descendants","text":"taskcat.exceptions.InvalidActionError taskcat._s3_stage.S3BucketCreatorException taskcat._amiupdater.AMIUpdaterFatalException taskcat._amiupdater.AMIUpdaterCommitNeededException","title":"Descendants"},{"location":"reference/taskcat/exceptions/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/taskcat/exceptions/#methods_1","text":"","title":"Methods"},{"location":"reference/taskcat/exceptions/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/taskcat/local_zones/","text":"Module taskcat.local_zones None None View Source ZONES = [ \"afs1-az1\", \"afs1-az2\", \"afs1-az3\", \"ape1-az1\", \"ape1-az2\", \"ape1-az3\", \"apne1-az1\", \"apne1-az2\", \"apne1-az4\", \"apne2-az1\", \"apne2-az2\", \"apne2-az3\", \"apne2-az4\", \"apne3-az1\", \"apne3-az2\", \"apne3-az3\", \"aps1-az1\", \"aps1-az2\", \"aps1-az3\", \"apse1-az1\", \"apse1-az2\", \"apse1-az3\", \"apse2-az1\", \"apse2-az2\", \"apse2-az3\", \"apse3-az1\", \"apse3-az2\", \"apse3-az3\", \"cac1-az1\", \"cac1-az2\", \"cac1-az4\", \"euc1-az1\", \"euc1-az2\", \"euc1-az3\", \"eun1-az1\", \"eun1-az2\", \"eun1-az3\", \"eus1-az1\", \"eus1-az2\", \"eus1-az3\", \"euw1-az1\", \"euw1-az2\", \"euw1-az3\", \"euw2-az1\", \"euw2-az2\", \"euw2-az3\", \"euw3-az1\", \"euw3-az2\", \"euw3-az3\", \"mes1-az1\", \"mes1-az2\", \"mes1-az3\", \"sae1-az1\", \"sae1-az2\", \"sae1-az3\", \"use1-atl1-az1\", \"use1-az1\", \"use1-az2\", \"use1-az3\", \"use1-az4\", \"use1-az5\", \"use1-az6\", \"use1-bos1-az1\", \"use1-chi1-az1\", \"use1-dfw1-az1\", \"use1-iah1-az1\", \"use1-mci1-az1\", \"use1-mia1-az1\", \"use1-msp1-az1\", \"use1-nyc1-az1\", \"use1-phl1-az1\", \"use2-az1\", \"use2-az2\", \"use2-az3\", \"usw1-az1\", \"usw1-az3\", \"usw2-az1\", \"usw2-az2\", \"usw2-az3\", \"usw2-az4\", \"usw2-den1-az1\", \"usw2-las1-az1\", \"usw2-lax1-az1\", \"usw2-lax1-az2\", \"usw2-pdx1-az1\", \"usw2-phx1-az1\", \"usw2-sea1-az1\", ] Variables ZONES","title":"Local Zones"},{"location":"reference/taskcat/local_zones/#module-taskcatlocal_zones","text":"None None View Source ZONES = [ \"afs1-az1\", \"afs1-az2\", \"afs1-az3\", \"ape1-az1\", \"ape1-az2\", \"ape1-az3\", \"apne1-az1\", \"apne1-az2\", \"apne1-az4\", \"apne2-az1\", \"apne2-az2\", \"apne2-az3\", \"apne2-az4\", \"apne3-az1\", \"apne3-az2\", \"apne3-az3\", \"aps1-az1\", \"aps1-az2\", \"aps1-az3\", \"apse1-az1\", \"apse1-az2\", \"apse1-az3\", \"apse2-az1\", \"apse2-az2\", \"apse2-az3\", \"apse3-az1\", \"apse3-az2\", \"apse3-az3\", \"cac1-az1\", \"cac1-az2\", \"cac1-az4\", \"euc1-az1\", \"euc1-az2\", \"euc1-az3\", \"eun1-az1\", \"eun1-az2\", \"eun1-az3\", \"eus1-az1\", \"eus1-az2\", \"eus1-az3\", \"euw1-az1\", \"euw1-az2\", \"euw1-az3\", \"euw2-az1\", \"euw2-az2\", \"euw2-az3\", \"euw3-az1\", \"euw3-az2\", \"euw3-az3\", \"mes1-az1\", \"mes1-az2\", \"mes1-az3\", \"sae1-az1\", \"sae1-az2\", \"sae1-az3\", \"use1-atl1-az1\", \"use1-az1\", \"use1-az2\", \"use1-az3\", \"use1-az4\", \"use1-az5\", \"use1-az6\", \"use1-bos1-az1\", \"use1-chi1-az1\", \"use1-dfw1-az1\", \"use1-iah1-az1\", \"use1-mci1-az1\", \"use1-mia1-az1\", \"use1-msp1-az1\", \"use1-nyc1-az1\", \"use1-phl1-az1\", \"use2-az1\", \"use2-az2\", \"use2-az3\", \"usw1-az1\", \"usw1-az3\", \"usw2-az1\", \"usw2-az2\", \"usw2-az3\", \"usw2-az4\", \"usw2-den1-az1\", \"usw2-las1-az1\", \"usw2-lax1-az1\", \"usw2-lax1-az2\", \"usw2-pdx1-az1\", \"usw2-phx1-az1\", \"usw2-sea1-az1\", ]","title":"Module taskcat.local_zones"},{"location":"reference/taskcat/local_zones/#variables","text":"ZONES","title":"Variables"},{"location":"reference/taskcat/regions_to_partitions/","text":"Module taskcat.regions_to_partitions None None View Source REGIONS = { \"af-south-1\": \"aws\", \"ap-east-1\": \"aws\", \"ap-northeast-1\": \"aws\", \"ap-northeast-2\": \"aws\", \"ap-northeast-3\": \"aws\", \"ap-south-1\": \"aws\", \"ap-southeast-1\": \"aws\", \"ap-southeast-2\": \"aws\", \"ap-southeast-3\": \"aws\", \"ca-central-1\": \"aws\", \"eu-central-1\": \"aws\", \"eu-north-1\": \"aws\", \"eu-south-1\": \"aws\", \"eu-west-1\": \"aws\", \"eu-west-2\": \"aws\", \"eu-west-3\": \"aws\", \"me-central-1\": \"aws\", \"me-south-1\": \"aws\", \"sa-east-1\": \"aws\", \"us-east-1\": \"aws\", \"us-east-2\": \"aws\", \"us-west-1\": \"aws\", \"us-west-2\": \"aws\", \"cn-north-1\": \"aws-cn\", \"cn-northwest-1\": \"aws-cn\", \"us-gov-east-1\": \"aws-us-gov\", \"us-gov-west-1\": \"aws-us-gov\", \"us-iso-east-1\": \"aws-iso\", \"us-iso-west-1\": \"aws-iso\", \"us-isob-east-1\": \"aws-iso-b\" } PARTITIONS = { \"aws\": [ \"af-south-1\", \"ap-east-1\", \"ap-northeast-1\", \"ap-northeast-2\", \"ap-northeast-3\", \"ap-south-1\", \"ap-southeast-1\", \"ap-southeast-2\", \"ap-southeast-3\", \"ca-central-1\", \"eu-central-1\", \"eu-north-1\", \"eu-south-1\", \"eu-west-1\", \"eu-west-2\", \"eu-west-3\", \"me-central-1\", \"me-south-1\", \"sa-east-1\", \"us-east-1\", \"us-east-2\", \"us-west-1\", \"us-west-2\" ], \"aws-cn\": [ \"cn-north-1\", \"cn-northwest-1\" ], \"aws-us-gov\": [ \"us-gov-east-1\", \"us-gov-west-1\" ], \"aws-iso\": [ \"us-iso-east-1\", \"us-iso-west-1\" ], \"aws-iso-b\": [ \"us-isob-east-1\" ] } Variables PARTITIONS REGIONS","title":"Regions To Partitions"},{"location":"reference/taskcat/regions_to_partitions/#module-taskcatregions_to_partitions","text":"None None View Source REGIONS = { \"af-south-1\": \"aws\", \"ap-east-1\": \"aws\", \"ap-northeast-1\": \"aws\", \"ap-northeast-2\": \"aws\", \"ap-northeast-3\": \"aws\", \"ap-south-1\": \"aws\", \"ap-southeast-1\": \"aws\", \"ap-southeast-2\": \"aws\", \"ap-southeast-3\": \"aws\", \"ca-central-1\": \"aws\", \"eu-central-1\": \"aws\", \"eu-north-1\": \"aws\", \"eu-south-1\": \"aws\", \"eu-west-1\": \"aws\", \"eu-west-2\": \"aws\", \"eu-west-3\": \"aws\", \"me-central-1\": \"aws\", \"me-south-1\": \"aws\", \"sa-east-1\": \"aws\", \"us-east-1\": \"aws\", \"us-east-2\": \"aws\", \"us-west-1\": \"aws\", \"us-west-2\": \"aws\", \"cn-north-1\": \"aws-cn\", \"cn-northwest-1\": \"aws-cn\", \"us-gov-east-1\": \"aws-us-gov\", \"us-gov-west-1\": \"aws-us-gov\", \"us-iso-east-1\": \"aws-iso\", \"us-iso-west-1\": \"aws-iso\", \"us-isob-east-1\": \"aws-iso-b\" } PARTITIONS = { \"aws\": [ \"af-south-1\", \"ap-east-1\", \"ap-northeast-1\", \"ap-northeast-2\", \"ap-northeast-3\", \"ap-south-1\", \"ap-southeast-1\", \"ap-southeast-2\", \"ap-southeast-3\", \"ca-central-1\", \"eu-central-1\", \"eu-north-1\", \"eu-south-1\", \"eu-west-1\", \"eu-west-2\", \"eu-west-3\", \"me-central-1\", \"me-south-1\", \"sa-east-1\", \"us-east-1\", \"us-east-2\", \"us-west-1\", \"us-west-2\" ], \"aws-cn\": [ \"cn-north-1\", \"cn-northwest-1\" ], \"aws-us-gov\": [ \"us-gov-east-1\", \"us-gov-west-1\" ], \"aws-iso\": [ \"us-iso-east-1\", \"us-iso-west-1\" ], \"aws-iso-b\": [ \"us-isob-east-1\" ] }","title":"Module taskcat.regions_to_partitions"},{"location":"reference/taskcat/regions_to_partitions/#variables","text":"PARTITIONS REGIONS","title":"Variables"},{"location":"reference/taskcat/iam_policy/","text":"Module taskcat.iam_policy None None Sub-modules taskcat.iam_policy.policy taskcat.iam_policy.tools","title":"Index"},{"location":"reference/taskcat/iam_policy/#module-taskcatiam_policy","text":"None None","title":"Module taskcat.iam_policy"},{"location":"reference/taskcat/iam_policy/#sub-modules","text":"taskcat.iam_policy.policy taskcat.iam_policy.tools","title":"Sub-modules"},{"location":"reference/taskcat/iam_policy/policy/","text":"Module taskcat.iam_policy.policy None None View Source import json import logging from pathlib import Path from typing import List import pkg_resources from taskcat._config import Config LOG = logging . getLogger ( __name__ ) class CFNPolicyGenerator : def __init__ ( self , config : Config , output_file : str ): self . _config = config self . _data_file_path = pkg_resources . resource_filename ( \"taskcat\" , \"/cfg/cfn_resource_iam_policy.json\" ) self . _output_file = output_file def generate_policy ( self ): LOG . warning ( \"This is an ALPHA feature. Use with caution\" ) templates = [] for template in self . _config . get_templates () . values (): templates . append ( template ) templates += list ( template . descendents ) resource_types = set () for template in templates : for _resource_name , _resource in template . template [ \"Resources\" ] . items (): resource_types . add ( _resource [ \"Type\" ]) policy = self . _policy_from_resource_types ( list ( resource_types )) with open ( Path ( self . _output_file ) . resolve (), \"w\" , encoding = \"utf-8\" ) as _f : _f . write ( json . dumps ( policy , indent = 4 , sort_keys = True )) @staticmethod def _generate_placeholder ( resource_type_name ): svc_name = resource_type_name . split ( \"::\" )[ 1 ] . lower () _x = { \"create\" : [ f \" { svc_name } :*\" ], \"read\" : [ f \" { svc_name } :*\" ], \"update\" : [ f \" { svc_name } :*\" ], \"delete\" : [ f \" { svc_name } :*\" ], } return _x def _policy_from_resource_types ( self , resource_types : List [ str ]): with open ( self . _data_file_path , encoding = \"utf-8\" ) as _f : data = json . load ( _f ) _policy = { \"Version\" : \"2012-10-17\" , \"Statement\" : []} _statements : dict = { \"create\" : set (), \"read\" : set (), \"update\" : set (), \"delete\" : set (), } for resource in resource_types : for k , v in data . get ( resource , self . _generate_placeholder ( resource ) ) . items (): for action in v : _statements [ k ] . add ( action ) for k , v in _statements . items (): _policy [ \"Statement\" ] . append ( { \"Sid\" : f \" { k . upper () } Actions\" , \"Effect\" : \"Allow\" , \"Action\" : sorted ( v ), \"Resource\" : \"*\" , } ) LOG . warning ( \"NOTE: The generated IAM policy will contain <service>:* IAM Actions where a\" + \" coverage gap exists within the CloudFormation Resource Spec\" ) LOG . warning ( \"Provide feedback to the CloudFormation team via: \" + \"https://github.com/aws-cloudformation/cloudformation-coverage-roadmap \" ) return _policy Variables LOG Classes CFNPolicyGenerator class CFNPolicyGenerator ( config : taskcat . _config . Config , output_file : str ) View Source class CFNPolicyGenerator : def __init__ ( self , config : Config , output_file : str ) : self . _config = config self . _data_file_path = pkg_resources . resource_filename ( \"taskcat\" , \"/cfg/cfn_resource_iam_policy.json\" ) self . _output_file = output_file def generate_policy ( self ) : LOG . warning ( \"This is an ALPHA feature. Use with caution\" ) templates = [] for template in self . _config . get_templates (). values () : templates . append ( template ) templates += list ( template . descendents ) resource_types = set () for template in templates : for _resource_name , _resource in template . template [ \"Resources\" ] . items () : resource_types . add ( _resource [ \"Type\" ] ) policy = self . _policy_from_resource_types ( list ( resource_types )) with open ( Path ( self . _output_file ). resolve (), \"w\" , encoding = \"utf-8\" ) as _f : _f . write ( json . dumps ( policy , indent = 4 , sort_keys = True )) @staticmethod def _generate_placeholder ( resource_type_name ) : svc_name = resource_type_name . split ( \"::\" ) [ 1 ] . lower () _x = { \"create\" : [ f\"{svc_name}:*\" ] , \"read\" : [ f\"{svc_name}:*\" ] , \"update\" : [ f\"{svc_name}:*\" ] , \"delete\" : [ f\"{svc_name}:*\" ] , } return _x def _policy_from_resource_types ( self , resource_types : List [ str ] ) : with open ( self . _data_file_path , encoding = \"utf-8\" ) as _f : data = json . load ( _f ) _policy = { \"Version\" : \"2012-10-17\" , \"Statement\" : []} _statements : dict = { \"create\" : set (), \"read\" : set (), \"update\" : set (), \"delete\" : set (), } for resource in resource_types : for k , v in data . get ( resource , self . _generate_placeholder ( resource ) ). items () : for action in v : _statements [ k ] . add ( action ) for k , v in _statements . items () : _policy [ \"Statement\" ] . append ( { \"Sid\" : f \"{k.upper()}Actions\" , \"Effect\" : \"Allow\" , \"Action\" : sorted ( v ), \"Resource\" : \"*\" , } ) LOG . warning ( \"NOTE: The generated IAM policy will contain <service>:* IAM Actions where a\" + \" coverage gap exists within the CloudFormation Resource Spec\" ) LOG . warning ( \"Provide feedback to the CloudFormation team via: \" + \"https://github.com/aws-cloudformation/cloudformation-coverage-roadmap \" ) return _policy Methods generate_policy def generate_policy ( self ) View Source def generate_policy ( self ) : LOG . warning ( \"This is an ALPHA feature. Use with caution\" ) templates = [] for template in self . _config . get_templates () . values () : templates . append ( template ) templates += list ( template . descendents ) resource_types = set () for template in templates : for _resource_name , _resource in template . template [ \"Resources\" ]. items () : resource_types . add ( _resource [ \"Type\" ] ) policy = self . _policy_from_resource_types ( list ( resource_types )) with open ( Path ( self . _output_file ) . resolve () , \"w\" , encoding = \"utf-8\" ) as _f : _f . write ( json . dumps ( policy , indent = 4 , sort_keys = True ))","title":"Policy"},{"location":"reference/taskcat/iam_policy/policy/#module-taskcatiam_policypolicy","text":"None None View Source import json import logging from pathlib import Path from typing import List import pkg_resources from taskcat._config import Config LOG = logging . getLogger ( __name__ ) class CFNPolicyGenerator : def __init__ ( self , config : Config , output_file : str ): self . _config = config self . _data_file_path = pkg_resources . resource_filename ( \"taskcat\" , \"/cfg/cfn_resource_iam_policy.json\" ) self . _output_file = output_file def generate_policy ( self ): LOG . warning ( \"This is an ALPHA feature. Use with caution\" ) templates = [] for template in self . _config . get_templates () . values (): templates . append ( template ) templates += list ( template . descendents ) resource_types = set () for template in templates : for _resource_name , _resource in template . template [ \"Resources\" ] . items (): resource_types . add ( _resource [ \"Type\" ]) policy = self . _policy_from_resource_types ( list ( resource_types )) with open ( Path ( self . _output_file ) . resolve (), \"w\" , encoding = \"utf-8\" ) as _f : _f . write ( json . dumps ( policy , indent = 4 , sort_keys = True )) @staticmethod def _generate_placeholder ( resource_type_name ): svc_name = resource_type_name . split ( \"::\" )[ 1 ] . lower () _x = { \"create\" : [ f \" { svc_name } :*\" ], \"read\" : [ f \" { svc_name } :*\" ], \"update\" : [ f \" { svc_name } :*\" ], \"delete\" : [ f \" { svc_name } :*\" ], } return _x def _policy_from_resource_types ( self , resource_types : List [ str ]): with open ( self . _data_file_path , encoding = \"utf-8\" ) as _f : data = json . load ( _f ) _policy = { \"Version\" : \"2012-10-17\" , \"Statement\" : []} _statements : dict = { \"create\" : set (), \"read\" : set (), \"update\" : set (), \"delete\" : set (), } for resource in resource_types : for k , v in data . get ( resource , self . _generate_placeholder ( resource ) ) . items (): for action in v : _statements [ k ] . add ( action ) for k , v in _statements . items (): _policy [ \"Statement\" ] . append ( { \"Sid\" : f \" { k . upper () } Actions\" , \"Effect\" : \"Allow\" , \"Action\" : sorted ( v ), \"Resource\" : \"*\" , } ) LOG . warning ( \"NOTE: The generated IAM policy will contain <service>:* IAM Actions where a\" + \" coverage gap exists within the CloudFormation Resource Spec\" ) LOG . warning ( \"Provide feedback to the CloudFormation team via: \" + \"https://github.com/aws-cloudformation/cloudformation-coverage-roadmap \" ) return _policy","title":"Module taskcat.iam_policy.policy"},{"location":"reference/taskcat/iam_policy/policy/#variables","text":"LOG","title":"Variables"},{"location":"reference/taskcat/iam_policy/policy/#classes","text":"","title":"Classes"},{"location":"reference/taskcat/iam_policy/policy/#cfnpolicygenerator","text":"class CFNPolicyGenerator ( config : taskcat . _config . Config , output_file : str ) View Source class CFNPolicyGenerator : def __init__ ( self , config : Config , output_file : str ) : self . _config = config self . _data_file_path = pkg_resources . resource_filename ( \"taskcat\" , \"/cfg/cfn_resource_iam_policy.json\" ) self . _output_file = output_file def generate_policy ( self ) : LOG . warning ( \"This is an ALPHA feature. Use with caution\" ) templates = [] for template in self . _config . get_templates (). values () : templates . append ( template ) templates += list ( template . descendents ) resource_types = set () for template in templates : for _resource_name , _resource in template . template [ \"Resources\" ] . items () : resource_types . add ( _resource [ \"Type\" ] ) policy = self . _policy_from_resource_types ( list ( resource_types )) with open ( Path ( self . _output_file ). resolve (), \"w\" , encoding = \"utf-8\" ) as _f : _f . write ( json . dumps ( policy , indent = 4 , sort_keys = True )) @staticmethod def _generate_placeholder ( resource_type_name ) : svc_name = resource_type_name . split ( \"::\" ) [ 1 ] . lower () _x = { \"create\" : [ f\"{svc_name}:*\" ] , \"read\" : [ f\"{svc_name}:*\" ] , \"update\" : [ f\"{svc_name}:*\" ] , \"delete\" : [ f\"{svc_name}:*\" ] , } return _x def _policy_from_resource_types ( self , resource_types : List [ str ] ) : with open ( self . _data_file_path , encoding = \"utf-8\" ) as _f : data = json . load ( _f ) _policy = { \"Version\" : \"2012-10-17\" , \"Statement\" : []} _statements : dict = { \"create\" : set (), \"read\" : set (), \"update\" : set (), \"delete\" : set (), } for resource in resource_types : for k , v in data . get ( resource , self . _generate_placeholder ( resource ) ). items () : for action in v : _statements [ k ] . add ( action ) for k , v in _statements . items () : _policy [ \"Statement\" ] . append ( { \"Sid\" : f \"{k.upper()}Actions\" , \"Effect\" : \"Allow\" , \"Action\" : sorted ( v ), \"Resource\" : \"*\" , } ) LOG . warning ( \"NOTE: The generated IAM policy will contain <service>:* IAM Actions where a\" + \" coverage gap exists within the CloudFormation Resource Spec\" ) LOG . warning ( \"Provide feedback to the CloudFormation team via: \" + \"https://github.com/aws-cloudformation/cloudformation-coverage-roadmap \" ) return _policy","title":"CFNPolicyGenerator"},{"location":"reference/taskcat/iam_policy/policy/#methods","text":"","title":"Methods"},{"location":"reference/taskcat/iam_policy/policy/#generate_policy","text":"def generate_policy ( self ) View Source def generate_policy ( self ) : LOG . warning ( \"This is an ALPHA feature. Use with caution\" ) templates = [] for template in self . _config . get_templates () . values () : templates . append ( template ) templates += list ( template . descendents ) resource_types = set () for template in templates : for _resource_name , _resource in template . template [ \"Resources\" ]. items () : resource_types . add ( _resource [ \"Type\" ] ) policy = self . _policy_from_resource_types ( list ( resource_types )) with open ( Path ( self . _output_file ) . resolve () , \"w\" , encoding = \"utf-8\" ) as _f : _f . write ( json . dumps ( policy , indent = 4 , sort_keys = True ))","title":"generate_policy"},{"location":"reference/taskcat/iam_policy/tools/","text":"Module taskcat.iam_policy.tools None None View Source import json import boto3 CFN = boto3 . client ( \"cloudformation\" ) def _get_all_resource_types (): _t = [] paginator = CFN . get_paginator ( \"list_types\" ) for page in paginator . paginate ( Visibility = \"PUBLIC\" , ProvisioningType = \"FULLY_MUTABLE\" , Type = \"RESOURCE\" , Filters = { \"Category\" : \"AWS_TYPES\" }, ): for _r in page [ \"TypeSummaries\" ]: _t . append ( _r [ \"TypeArn\" ]) return _t def _get_schema_for_resource_type ( resource_type_arn ): resp = CFN . describe_type ( Arn = resource_type_arn ) return json . loads ( resp [ \"Schema\" ]) def _transform_to_abbreviated_format ( schema ): result = { schema [ \"typeName\" ]: {}} for method in [ \"create\" , \"read\" , \"update\" , \"delete\" ]: transformed = [] for _z in schema [ \"handlers\" ][ method ][ \"permissions\" ]: if not _z : continue try : _x , _y = _z . split ( \":\" ) transformed . append ( f \" { _x . lower () } : { _y } \" ) except ValueError : transformed . append ( _z ) result [ schema [ \"typeName\" ]][ method ] = transformed return result Variables CFN","title":"Tools"},{"location":"reference/taskcat/iam_policy/tools/#module-taskcatiam_policytools","text":"None None View Source import json import boto3 CFN = boto3 . client ( \"cloudformation\" ) def _get_all_resource_types (): _t = [] paginator = CFN . get_paginator ( \"list_types\" ) for page in paginator . paginate ( Visibility = \"PUBLIC\" , ProvisioningType = \"FULLY_MUTABLE\" , Type = \"RESOURCE\" , Filters = { \"Category\" : \"AWS_TYPES\" }, ): for _r in page [ \"TypeSummaries\" ]: _t . append ( _r [ \"TypeArn\" ]) return _t def _get_schema_for_resource_type ( resource_type_arn ): resp = CFN . describe_type ( Arn = resource_type_arn ) return json . loads ( resp [ \"Schema\" ]) def _transform_to_abbreviated_format ( schema ): result = { schema [ \"typeName\" ]: {}} for method in [ \"create\" , \"read\" , \"update\" , \"delete\" ]: transformed = [] for _z in schema [ \"handlers\" ][ method ][ \"permissions\" ]: if not _z : continue try : _x , _y = _z . split ( \":\" ) transformed . append ( f \" { _x . lower () } : { _y } \" ) except ValueError : transformed . append ( _z ) result [ schema [ \"typeName\" ]][ method ] = transformed return result","title":"Module taskcat.iam_policy.tools"},{"location":"reference/taskcat/iam_policy/tools/#variables","text":"CFN","title":"Variables"},{"location":"reference/taskcat/testing/","text":"Module taskcat.testing None None View Source from ._cfn_test import CFNTest # noqa: F401 from ._lint_test import LintTest # noqa: F401 from ._unit_test import UnitTest # noqa: F401 __all__ = [ \"CFNTest\" ] Sub-modules taskcat.testing.base_test Classes CFNTest class CFNTest ( config : taskcat . _config . Config , printer : Union [ taskcat . _tui . TerminalPrinter , NoneType ] = None , test_names : str = 'ALL' , regions : str = 'ALL' , skip_upload : bool = False , lint_disable : bool = False , no_delete : bool = False , keep_failed : bool = False , dont_wait_for_delete : bool = True , _extra_tags : list = None ) View Source class CFNTest ( BaseTest ): # pylint: disable=too-many-instance-attributes \"\"\" Tests Cloudformation template by making sure the stack can properly deploy in the specified regions. \"\"\" def __init__ ( self , config : Config , printer : Union [ TerminalPrinter , None ] = None , test_names : str = \"ALL\" , regions : str = \"ALL\" , skip_upload : bool = False , lint_disable : bool = False , no_delete : bool = False , keep_failed : bool = False , dont_wait_for_delete : bool = True , _extra_tags : list = None , ): \"\"\"The constructor creates a test from the given Config object. Args: config (Config): A pre-configured Taskcat Config instance. printer (Union[TerminalPrinter, None], optional): A printer object that will handle Test output. Defaults to TerminalPrinter. test_names (str, optional): A comma separated list of tests to run. Defaults to \"ALL\". regions (str, optional): A comma separated list of regions to test in. Defaults to \"ALL\". skip_upload (bool, optional): Use templates in an existing cloudformation bucket. Defaults to False. lint_disable (bool, optional): Disable linting with cfn-lint. Defaults to False. no_delete (bool, optional): Don't delete stacks after test is complete. Defaults to False. keep_failed (bool, optional): Don't delete failed stacks. Defaults to False. dont_wait_for_delete (bool, optional): Exits immediately after calling stack_delete. Defaults to True. \"\"\" # noqa: B950 super () . __init__ ( config ) self . test_definition : Stacker self . test_names = test_names self . regions = regions self . skip_upload = skip_upload self . lint_disable = lint_disable self . no_delete = no_delete self . keep_failed = keep_failed self . dont_wait_for_delete = dont_wait_for_delete self . _extra_tags = _extra_tags if _extra_tags else [] if printer is None : self . printer = TerminalPrinter ( minimalist = True ) else : self . printer = printer def run ( self ) -> None : \"\"\"Deploys the required Test resources in AWS. Raises: TaskCatException: If skip_upload is set without specifying s3_bucket in config. TaskCatException: If linting fails with errors. \"\"\" _trim_regions ( self . regions , self . config ) _trim_tests ( self . test_names , self . config ) boto3_cache = Boto3Cache () templates = self . config . get_templates () if self . skip_upload and not self . config . config . project . s3_bucket : raise TaskCatException ( \"cannot skip_buckets without specifying s3_bucket in config\" ) buckets = self . config . get_buckets ( boto3_cache ) if not self . skip_upload : # 1. lint if not self . lint_disable : lint = TaskCatLint ( self . config , templates ) errors = lint . lints [ 1 ] lint . output_results () if errors or not lint . passed : raise TaskCatException ( \"Lint failed with errors\" ) # 2. build lambdas if self . config . config . project . package_lambda : LambdaBuild ( self . config , self . config . project_root ) # 3. s3 sync stage_in_s3 ( buckets , self . config . config . project . name , self . config . project_root , [] ) regions = self . config . get_regions ( boto3_cache ) parameters = self . config . get_rendered_parameters ( buckets , regions , templates ) tests = self . config . get_tests ( templates , regions , buckets , parameters ) # pre-hooks execute_hooks ( \"prehooks\" , self . config , tests , parameters ) self . test_definition = Stacker ( self . config . config . project . name , tests , shorten_stack_name = self . config . config . project . shorten_stack_name , tags = self . _extra_tags , ) self . test_definition . create_stacks () # post-hooks # TODO: pass in outputs, once there is a standard interface for a test_definition execute_hooks ( \"posthooks\" , self . config , tests , parameters ) self . printer . report_test_progress ( stacker = self . test_definition ) self . passed = True self . result = self . test_definition . stacks def clean_up ( self ) -> None : # noqa: C901 \"\"\"Deletes the Test related resources in AWS. Raises: TaskCatException: If one or more stacks failed to create. \"\"\" if not hasattr ( self , \"test_definition\" ): LOG . warning ( \"No stacks were created... skipping cleanup.\" ) return status = self . test_definition . status () # Delete Stacks if self . no_delete : LOG . info ( \"Skipping delete due to cli argument\" ) elif self . keep_failed : if len ( status [ \"COMPLETE\" ]) > 0 : LOG . info ( \"deleting successful stacks\" ) self . test_definition . delete_stacks ({ \"status\" : \"CREATE_COMPLETE\" }) else : self . test_definition . delete_stacks () if not self . dont_wait_for_delete : self . printer . report_test_progress ( stacker = self . test_definition ) # TODO: summarise stack statusses (did they complete/delete ok) and print any # error events # Delete Templates and Buckets buckets = self . config . get_buckets () if not self . no_delete or ( self . keep_failed is True and len ( status [ \"FAILED\" ]) == 0 ): deleted : ListType [ str ] = [] for test in buckets . values (): for bucket in test . values (): if ( bucket . name not in deleted ) and not bucket . regional_buckets : bucket . delete ( delete_objects = True ) deleted . append ( bucket . name ) # 9. raise if something failed # - grabbing the status again to ensure everything deleted OK. status = self . test_definition . status () if len ( status [ \"FAILED\" ]) > 0 : raise TaskCatException ( f 'One or more stacks failed to create: {status[\"FAILED\"]}' ) def report ( self , output_directory : str = \"./taskcat_outputs\" , ): \"\"\"Generates a report of the status of Cloudformation stacks. Args: output_directory (str, optional): The directory to save the report in. Defaults to \"./taskcat_outputs\". \"\"\" # noqa: B950 report_path = Path ( output_directory ) . resolve () report_path . mkdir ( exist_ok = True ) cfn_logs = _CfnLogTools () cfn_logs . createcfnlogs ( self . test_definition , report_path ) ReportBuilder ( self . test_definition , report_path / \"index.html\" ) . generate_report () Ancestors (in MRO) taskcat.testing.base_test.BaseTest taskcat.testing._abstract_test.Test abc.ABC Static methods from_dict def from_dict ( input_config : dict , project_root : str = './' , regions : str = 'ALL' , enable_sig_v2 : bool = False ) -> ~ T Creates a Test from a Taskcat configuration in dictionary form. Parameters: Name Type Description Default input_config dict A Taskcat configuration in the form of a dict. None project_root str The path to the directory with your template and config file. Defaults to \"./\". \"./\" regions str A comma separated list of regions to test in. Defaults to \"ALL\". \"ALL\" enable_sig_v2 bool Enable legacy sigv2 requests for auto-created buckets. Defaults to False. False Returns: Type Description T Returns a Test instance. View Source @classmethod def from_dict ( cls : Type [ T ] , input_config : dict , project_root : str = \"./\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat configuration in dictionary form. Args: input_config (dict): A Taskcat configuration in the form of a dict. project_root (str, optional): The path to the directory with your template and config file. Defaults to \" . / \". regions (str, optional): A comma separated list of regions to test in. Defaults to \" ALL \". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa : B950 project_root_path : Path = Path ( project_root ). expanduser (). resolve () # pylint : disable = too - many - arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) sources = [ {\"source\": \"Manual\", \"config\": input_config}, {\"source\": \"CliArgument\", \"config\": args}, ] config = Config ( uid = uuid . uuid4 (), project_root = project_root_path , sources = sources ) return cls ( config ) from_file def from_file ( project_root : str = './' , input_file : str = './.taskcat.yml' , regions : str = 'ALL' , enable_sig_v2 : bool = False ) -> ~ T Creates a Test from a Taskcat config file. Parameters: Name Type Description Default project_root str The path to the directory with your template and config file. Defaults to \"./\". \"./\" input_file str The name of the Taskcat confile file. Defaults to \"./.taskcat.yml\". \"./.taskcat.yml\" regions str A comma separated list of regions to test in. Defaults to \"ALL\". \"ALL\" enable_sig_v2 bool Enable legacy sigv2 requests for auto-created buckets. Defaults to False. False Returns: Type Description T Returns a Test instance. View Source @classmethod def from_file ( cls : Type [ T ] , project_root : str = \"./\" , input_file : str = \"./.taskcat.yml\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat config file. Args: project_root (str, optional): The path to the directory with your template and config file. Defaults to \" . / \". input_file (str, optional): The name of the Taskcat confile file. Defaults to \" . / . taskcat . yml \". regions (str, optional): A comma separated list of regions to test in. Defaults to \" ALL \". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa : B950 project_root_path : Path = Path ( project_root ). expanduser (). resolve () input_file_path : Path = project_root_path / input_file # pylint : disable = too - many - arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) config = Config . create ( project_root = project_root_path , project_config_path = input_file_path , args = args # TODO : detect if input file is taskcat config or CloudFormation template ) return cls ( config ) Instance variables config passed result Methods clean_up def clean_up ( self ) -> None Deletes the Test related resources in AWS. Raises: Type Description TaskCatException If one or more stacks failed to create. View Source def clean_up ( self ) -> None : # noqa : C901 \"\"\"Deletes the Test related resources in AWS. Raises: TaskCatException: If one or more stacks failed to create. \"\"\" if not hasattr ( self , \"test_definition\" ) : LOG . warning ( \"No stacks were created... skipping cleanup.\" ) return status = self . test_definition . status () # Delete Stacks if self . no_delete : LOG . info ( \"Skipping delete due to cli argument\" ) elif self . keep_failed : if len ( status [ \"COMPLETE\" ] ) > 0 : LOG . info ( \"deleting successful stacks\" ) self . test_definition . delete_stacks ( { \"status\" : \"CREATE_COMPLETE\" } ) else : self . test_definition . delete_stacks () if not self . dont_wait_for_delete : self . printer . report_test_progress ( stacker = self . test_definition ) # TODO : summarise stack statusses ( did they complete / delete ok ) and print any # error events # Delete Templates and Buckets buckets = self . config . get_buckets () if not self . no_delete or ( self . keep_failed is True and len ( status [ \"FAILED\" ] ) == 0 ) : deleted : ListType [ str ] = [] for test in buckets . values () : for bucket in test . values () : if ( bucket . name not in deleted ) and not bucket . regional_buckets : bucket . delete ( delete_objects = True ) deleted . append ( bucket . name ) # 9. raise if something failed # - grabbing the status again to ensure everything deleted OK . status = self . test_definition . status () if len ( status [ \"FAILED\" ] ) > 0 : raise TaskCatException ( f 'One or more stacks failed to create: {status[\"FAILED\"]}' ) report def report ( self , output_directory : str = './taskcat_outputs' ) Generates a report of the status of Cloudformation stacks. Parameters: Name Type Description Default output_directory str The directory to save the report in. Defaults to \"./taskcat_outputs\". \"./taskcat_outputs\" View Source def report( self, output_directory: str = \"./taskcat_outputs\", ): \"\"\"Generates a report of the status of Cloudformation stacks. Args: output_directory (str, optional): The directory to save the report in. Defaults to \"./taskcat_outputs\". \"\"\" # noqa: B950 report_path = Path(output_directory).resolve() report_path.mkdir(exist_ok=True) cfn_logs = _CfnLogTools() cfn_logs.createcfnlogs(self.test_definition, report_path) ReportBuilder( self.test_definition, report_path / \"index.html\" ).generate_report() run def run ( self ) -> None Deploys the required Test resources in AWS. Raises: Type Description TaskCatException If skip_upload is set without specifying s3_bucket in config. TaskCatException If linting fails with errors. View Source def run ( self ) -> None : \"\"\"Deploys the required Test resources in AWS. Raises: TaskCatException: If skip_upload is set without specifying s3_bucket in config. TaskCatException: If linting fails with errors. \"\"\" _trim_regions ( self . regions , self . config ) _trim_tests ( self . test_names , self . config ) boto3_cache = Boto3Cache () templates = self . config . get_templates () if self . skip_upload and not self . config . config . project . s3_bucket : raise TaskCatException ( \"cannot skip_buckets without specifying s3_bucket in config\" ) buckets = self . config . get_buckets ( boto3_cache ) if not self . skip_upload : # 1. lint if not self . lint_disable : lint = TaskCatLint ( self . config , templates ) errors = lint . lints [ 1 ] lint . output_results () if errors or not lint . passed : raise TaskCatException ( \"Lint failed with errors\" ) # 2. build lambdas if self . config . config . project . package_lambda : LambdaBuild ( self . config , self . config . project_root ) # 3. s3 sync stage_in_s3 ( buckets , self . config . config . project . name , self . config . project_root , [] ) regions = self . config . get_regions ( boto3_cache ) parameters = self . config . get_rendered_parameters ( buckets , regions , templates ) tests = self . config . get_tests ( templates , regions , buckets , parameters ) # pre-hooks execute_hooks ( \"prehooks\" , self . config , tests , parameters ) self . test_definition = Stacker ( self . config . config . project . name , tests , shorten_stack_name = self . config . config . project . shorten_stack_name , tags = self . _extra_tags , ) self . test_definition . create_stacks () # post-hooks # TODO: pass in outputs, once there is a standard interface for a test_definition execute_hooks ( \"posthooks\" , self . config , tests , parameters ) self . printer . report_test_progress ( stacker = self . test_definition ) self . passed = True self . result = self . test_definition . stacks","title":"Index"},{"location":"reference/taskcat/testing/#module-taskcattesting","text":"None None View Source from ._cfn_test import CFNTest # noqa: F401 from ._lint_test import LintTest # noqa: F401 from ._unit_test import UnitTest # noqa: F401 __all__ = [ \"CFNTest\" ]","title":"Module taskcat.testing"},{"location":"reference/taskcat/testing/#sub-modules","text":"taskcat.testing.base_test","title":"Sub-modules"},{"location":"reference/taskcat/testing/#classes","text":"","title":"Classes"},{"location":"reference/taskcat/testing/#cfntest","text":"class CFNTest ( config : taskcat . _config . Config , printer : Union [ taskcat . _tui . TerminalPrinter , NoneType ] = None , test_names : str = 'ALL' , regions : str = 'ALL' , skip_upload : bool = False , lint_disable : bool = False , no_delete : bool = False , keep_failed : bool = False , dont_wait_for_delete : bool = True , _extra_tags : list = None ) View Source class CFNTest ( BaseTest ): # pylint: disable=too-many-instance-attributes \"\"\" Tests Cloudformation template by making sure the stack can properly deploy in the specified regions. \"\"\" def __init__ ( self , config : Config , printer : Union [ TerminalPrinter , None ] = None , test_names : str = \"ALL\" , regions : str = \"ALL\" , skip_upload : bool = False , lint_disable : bool = False , no_delete : bool = False , keep_failed : bool = False , dont_wait_for_delete : bool = True , _extra_tags : list = None , ): \"\"\"The constructor creates a test from the given Config object. Args: config (Config): A pre-configured Taskcat Config instance. printer (Union[TerminalPrinter, None], optional): A printer object that will handle Test output. Defaults to TerminalPrinter. test_names (str, optional): A comma separated list of tests to run. Defaults to \"ALL\". regions (str, optional): A comma separated list of regions to test in. Defaults to \"ALL\". skip_upload (bool, optional): Use templates in an existing cloudformation bucket. Defaults to False. lint_disable (bool, optional): Disable linting with cfn-lint. Defaults to False. no_delete (bool, optional): Don't delete stacks after test is complete. Defaults to False. keep_failed (bool, optional): Don't delete failed stacks. Defaults to False. dont_wait_for_delete (bool, optional): Exits immediately after calling stack_delete. Defaults to True. \"\"\" # noqa: B950 super () . __init__ ( config ) self . test_definition : Stacker self . test_names = test_names self . regions = regions self . skip_upload = skip_upload self . lint_disable = lint_disable self . no_delete = no_delete self . keep_failed = keep_failed self . dont_wait_for_delete = dont_wait_for_delete self . _extra_tags = _extra_tags if _extra_tags else [] if printer is None : self . printer = TerminalPrinter ( minimalist = True ) else : self . printer = printer def run ( self ) -> None : \"\"\"Deploys the required Test resources in AWS. Raises: TaskCatException: If skip_upload is set without specifying s3_bucket in config. TaskCatException: If linting fails with errors. \"\"\" _trim_regions ( self . regions , self . config ) _trim_tests ( self . test_names , self . config ) boto3_cache = Boto3Cache () templates = self . config . get_templates () if self . skip_upload and not self . config . config . project . s3_bucket : raise TaskCatException ( \"cannot skip_buckets without specifying s3_bucket in config\" ) buckets = self . config . get_buckets ( boto3_cache ) if not self . skip_upload : # 1. lint if not self . lint_disable : lint = TaskCatLint ( self . config , templates ) errors = lint . lints [ 1 ] lint . output_results () if errors or not lint . passed : raise TaskCatException ( \"Lint failed with errors\" ) # 2. build lambdas if self . config . config . project . package_lambda : LambdaBuild ( self . config , self . config . project_root ) # 3. s3 sync stage_in_s3 ( buckets , self . config . config . project . name , self . config . project_root , [] ) regions = self . config . get_regions ( boto3_cache ) parameters = self . config . get_rendered_parameters ( buckets , regions , templates ) tests = self . config . get_tests ( templates , regions , buckets , parameters ) # pre-hooks execute_hooks ( \"prehooks\" , self . config , tests , parameters ) self . test_definition = Stacker ( self . config . config . project . name , tests , shorten_stack_name = self . config . config . project . shorten_stack_name , tags = self . _extra_tags , ) self . test_definition . create_stacks () # post-hooks # TODO: pass in outputs, once there is a standard interface for a test_definition execute_hooks ( \"posthooks\" , self . config , tests , parameters ) self . printer . report_test_progress ( stacker = self . test_definition ) self . passed = True self . result = self . test_definition . stacks def clean_up ( self ) -> None : # noqa: C901 \"\"\"Deletes the Test related resources in AWS. Raises: TaskCatException: If one or more stacks failed to create. \"\"\" if not hasattr ( self , \"test_definition\" ): LOG . warning ( \"No stacks were created... skipping cleanup.\" ) return status = self . test_definition . status () # Delete Stacks if self . no_delete : LOG . info ( \"Skipping delete due to cli argument\" ) elif self . keep_failed : if len ( status [ \"COMPLETE\" ]) > 0 : LOG . info ( \"deleting successful stacks\" ) self . test_definition . delete_stacks ({ \"status\" : \"CREATE_COMPLETE\" }) else : self . test_definition . delete_stacks () if not self . dont_wait_for_delete : self . printer . report_test_progress ( stacker = self . test_definition ) # TODO: summarise stack statusses (did they complete/delete ok) and print any # error events # Delete Templates and Buckets buckets = self . config . get_buckets () if not self . no_delete or ( self . keep_failed is True and len ( status [ \"FAILED\" ]) == 0 ): deleted : ListType [ str ] = [] for test in buckets . values (): for bucket in test . values (): if ( bucket . name not in deleted ) and not bucket . regional_buckets : bucket . delete ( delete_objects = True ) deleted . append ( bucket . name ) # 9. raise if something failed # - grabbing the status again to ensure everything deleted OK. status = self . test_definition . status () if len ( status [ \"FAILED\" ]) > 0 : raise TaskCatException ( f 'One or more stacks failed to create: {status[\"FAILED\"]}' ) def report ( self , output_directory : str = \"./taskcat_outputs\" , ): \"\"\"Generates a report of the status of Cloudformation stacks. Args: output_directory (str, optional): The directory to save the report in. Defaults to \"./taskcat_outputs\". \"\"\" # noqa: B950 report_path = Path ( output_directory ) . resolve () report_path . mkdir ( exist_ok = True ) cfn_logs = _CfnLogTools () cfn_logs . createcfnlogs ( self . test_definition , report_path ) ReportBuilder ( self . test_definition , report_path / \"index.html\" ) . generate_report ()","title":"CFNTest"},{"location":"reference/taskcat/testing/#ancestors-in-mro","text":"taskcat.testing.base_test.BaseTest taskcat.testing._abstract_test.Test abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/taskcat/testing/#static-methods","text":"","title":"Static methods"},{"location":"reference/taskcat/testing/#from_dict","text":"def from_dict ( input_config : dict , project_root : str = './' , regions : str = 'ALL' , enable_sig_v2 : bool = False ) -> ~ T Creates a Test from a Taskcat configuration in dictionary form. Parameters: Name Type Description Default input_config dict A Taskcat configuration in the form of a dict. None project_root str The path to the directory with your template and config file. Defaults to \"./\". \"./\" regions str A comma separated list of regions to test in. Defaults to \"ALL\". \"ALL\" enable_sig_v2 bool Enable legacy sigv2 requests for auto-created buckets. Defaults to False. False Returns: Type Description T Returns a Test instance. View Source @classmethod def from_dict ( cls : Type [ T ] , input_config : dict , project_root : str = \"./\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat configuration in dictionary form. Args: input_config (dict): A Taskcat configuration in the form of a dict. project_root (str, optional): The path to the directory with your template and config file. Defaults to \" . / \". regions (str, optional): A comma separated list of regions to test in. Defaults to \" ALL \". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa : B950 project_root_path : Path = Path ( project_root ). expanduser (). resolve () # pylint : disable = too - many - arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) sources = [ {\"source\": \"Manual\", \"config\": input_config}, {\"source\": \"CliArgument\", \"config\": args}, ] config = Config ( uid = uuid . uuid4 (), project_root = project_root_path , sources = sources ) return cls ( config )","title":"from_dict"},{"location":"reference/taskcat/testing/#from_file","text":"def from_file ( project_root : str = './' , input_file : str = './.taskcat.yml' , regions : str = 'ALL' , enable_sig_v2 : bool = False ) -> ~ T Creates a Test from a Taskcat config file. Parameters: Name Type Description Default project_root str The path to the directory with your template and config file. Defaults to \"./\". \"./\" input_file str The name of the Taskcat confile file. Defaults to \"./.taskcat.yml\". \"./.taskcat.yml\" regions str A comma separated list of regions to test in. Defaults to \"ALL\". \"ALL\" enable_sig_v2 bool Enable legacy sigv2 requests for auto-created buckets. Defaults to False. False Returns: Type Description T Returns a Test instance. View Source @classmethod def from_file ( cls : Type [ T ] , project_root : str = \"./\" , input_file : str = \"./.taskcat.yml\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat config file. Args: project_root (str, optional): The path to the directory with your template and config file. Defaults to \" . / \". input_file (str, optional): The name of the Taskcat confile file. Defaults to \" . / . taskcat . yml \". regions (str, optional): A comma separated list of regions to test in. Defaults to \" ALL \". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa : B950 project_root_path : Path = Path ( project_root ). expanduser (). resolve () input_file_path : Path = project_root_path / input_file # pylint : disable = too - many - arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) config = Config . create ( project_root = project_root_path , project_config_path = input_file_path , args = args # TODO : detect if input file is taskcat config or CloudFormation template ) return cls ( config )","title":"from_file"},{"location":"reference/taskcat/testing/#instance-variables","text":"config passed result","title":"Instance variables"},{"location":"reference/taskcat/testing/#methods","text":"","title":"Methods"},{"location":"reference/taskcat/testing/#clean_up","text":"def clean_up ( self ) -> None Deletes the Test related resources in AWS. Raises: Type Description TaskCatException If one or more stacks failed to create. View Source def clean_up ( self ) -> None : # noqa : C901 \"\"\"Deletes the Test related resources in AWS. Raises: TaskCatException: If one or more stacks failed to create. \"\"\" if not hasattr ( self , \"test_definition\" ) : LOG . warning ( \"No stacks were created... skipping cleanup.\" ) return status = self . test_definition . status () # Delete Stacks if self . no_delete : LOG . info ( \"Skipping delete due to cli argument\" ) elif self . keep_failed : if len ( status [ \"COMPLETE\" ] ) > 0 : LOG . info ( \"deleting successful stacks\" ) self . test_definition . delete_stacks ( { \"status\" : \"CREATE_COMPLETE\" } ) else : self . test_definition . delete_stacks () if not self . dont_wait_for_delete : self . printer . report_test_progress ( stacker = self . test_definition ) # TODO : summarise stack statusses ( did they complete / delete ok ) and print any # error events # Delete Templates and Buckets buckets = self . config . get_buckets () if not self . no_delete or ( self . keep_failed is True and len ( status [ \"FAILED\" ] ) == 0 ) : deleted : ListType [ str ] = [] for test in buckets . values () : for bucket in test . values () : if ( bucket . name not in deleted ) and not bucket . regional_buckets : bucket . delete ( delete_objects = True ) deleted . append ( bucket . name ) # 9. raise if something failed # - grabbing the status again to ensure everything deleted OK . status = self . test_definition . status () if len ( status [ \"FAILED\" ] ) > 0 : raise TaskCatException ( f 'One or more stacks failed to create: {status[\"FAILED\"]}' )","title":"clean_up"},{"location":"reference/taskcat/testing/#report","text":"def report ( self , output_directory : str = './taskcat_outputs' ) Generates a report of the status of Cloudformation stacks. Parameters: Name Type Description Default output_directory str The directory to save the report in. Defaults to \"./taskcat_outputs\". \"./taskcat_outputs\" View Source def report( self, output_directory: str = \"./taskcat_outputs\", ): \"\"\"Generates a report of the status of Cloudformation stacks. Args: output_directory (str, optional): The directory to save the report in. Defaults to \"./taskcat_outputs\". \"\"\" # noqa: B950 report_path = Path(output_directory).resolve() report_path.mkdir(exist_ok=True) cfn_logs = _CfnLogTools() cfn_logs.createcfnlogs(self.test_definition, report_path) ReportBuilder( self.test_definition, report_path / \"index.html\" ).generate_report()","title":"report"},{"location":"reference/taskcat/testing/#run","text":"def run ( self ) -> None Deploys the required Test resources in AWS. Raises: Type Description TaskCatException If skip_upload is set without specifying s3_bucket in config. TaskCatException If linting fails with errors. View Source def run ( self ) -> None : \"\"\"Deploys the required Test resources in AWS. Raises: TaskCatException: If skip_upload is set without specifying s3_bucket in config. TaskCatException: If linting fails with errors. \"\"\" _trim_regions ( self . regions , self . config ) _trim_tests ( self . test_names , self . config ) boto3_cache = Boto3Cache () templates = self . config . get_templates () if self . skip_upload and not self . config . config . project . s3_bucket : raise TaskCatException ( \"cannot skip_buckets without specifying s3_bucket in config\" ) buckets = self . config . get_buckets ( boto3_cache ) if not self . skip_upload : # 1. lint if not self . lint_disable : lint = TaskCatLint ( self . config , templates ) errors = lint . lints [ 1 ] lint . output_results () if errors or not lint . passed : raise TaskCatException ( \"Lint failed with errors\" ) # 2. build lambdas if self . config . config . project . package_lambda : LambdaBuild ( self . config , self . config . project_root ) # 3. s3 sync stage_in_s3 ( buckets , self . config . config . project . name , self . config . project_root , [] ) regions = self . config . get_regions ( boto3_cache ) parameters = self . config . get_rendered_parameters ( buckets , regions , templates ) tests = self . config . get_tests ( templates , regions , buckets , parameters ) # pre-hooks execute_hooks ( \"prehooks\" , self . config , tests , parameters ) self . test_definition = Stacker ( self . config . config . project . name , tests , shorten_stack_name = self . config . config . project . shorten_stack_name , tags = self . _extra_tags , ) self . test_definition . create_stacks () # post-hooks # TODO: pass in outputs, once there is a standard interface for a test_definition execute_hooks ( \"posthooks\" , self . config , tests , parameters ) self . printer . report_test_progress ( stacker = self . test_definition ) self . passed = True self . result = self . test_definition . stacks","title":"run"},{"location":"reference/taskcat/testing/base_test/","text":"Module taskcat.testing.base_test None None View Source # pylint: disable=line-too-long import uuid from pathlib import Path from typing import Any , Dict , Type , TypeVar from taskcat._cli_core import GLOBAL_ARGS from taskcat._config import Config from ._abstract_test import Test T = TypeVar ( \"T\" , bound = \"BaseTest\" ) # pylint: disable=invalid-name class BaseTest ( Test ): \"\"\"A Generic Test Class that implements the passed and uid properties. Any subclass will still need to implement the the run and clean_up methods. \"\"\" def __init__ ( self , config : Config ): self . config : Config = config self . passed : bool = False self . result : Any = None @property def config ( self ) -> Config : return self . _config @config . setter def config ( self , config : Config ) -> None : # It should be possible to check if config is already set # and if it is throw an exception. Might be needed since # child objects rely on the configs uid. self . _config = config @property def passed ( self ) -> bool : return self . _passed @passed . setter def passed ( self , new_value : bool ) -> None : self . _passed = new_value @property def result ( self ) -> Any : return self . _result @result . setter def result ( self , new_value : Any ) -> None : self . _result = new_value def __enter__ ( self ): try : self . run () except BaseException as ex : self . clean_up () raise ex return self . result def __exit__ ( self , exc_type , exc_val , exc_tb ): # we could optionally call self.report() on exiting. self . clean_up () @classmethod def from_file ( cls : Type [ T ], project_root : str = \"./\" , input_file : str = \"./.taskcat.yml\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat config file. Args: project_root (str, optional): The path to the directory with your template and config file. Defaults to \"./\". input_file (str, optional): The name of the Taskcat confile file. Defaults to \"./.taskcat.yml\". regions (str, optional): A comma separated list of regions to test in. Defaults to \"ALL\". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa: B950 project_root_path : Path = Path ( project_root ) . expanduser () . resolve () input_file_path : Path = project_root_path / input_file # pylint: disable=too-many-arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) config = Config . create ( project_root = project_root_path , project_config_path = input_file_path , args = args # TODO: detect if input file is taskcat config or CloudFormation template ) return cls ( config ) @classmethod def from_dict ( cls : Type [ T ], input_config : dict , project_root : str = \"./\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat configuration in dictionary form. Args: input_config (dict): A Taskcat configuration in the form of a dict. project_root (str, optional): The path to the directory with your template and config file. Defaults to \"./\". regions (str, optional): A comma separated list of regions to test in. Defaults to \"ALL\". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa: B950 project_root_path : Path = Path ( project_root ) . expanduser () . resolve () # pylint: disable=too-many-arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) sources = [ { \"source\" : \"Manual\" , \"config\" : input_config }, { \"source\" : \"CliArgument\" , \"config\" : args }, ] config = Config ( uid = uuid . uuid4 (), project_root = project_root_path , sources = sources ) return cls ( config ) def _build_args ( enable_sig_v2 , regions , default_profile ): args : Dict [ str , Any ] = {} if enable_sig_v2 : args [ \"project\" ] = { \"s3_enable_sig_v2\" : enable_sig_v2 } if regions != \"ALL\" : if \"project\" not in args : args [ \"project\" ] = {} args [ \"project\" ][ \"regions\" ] = regions . split ( \",\" ) if default_profile : _auth_dict = { \"default\" : default_profile } if not args . get ( \"project\" ): args [ \"project\" ] = { \"auth\" : _auth_dict } else : args [ \"project\" ][ \"auth\" ] = _auth_dict return args Variables T Classes BaseTest class BaseTest ( config : taskcat . _config . Config ) View Source class BaseTest ( Test ) : \"\"\"A Generic Test Class that implements the passed and uid properties. Any subclass will still need to implement the the run and clean_up methods. \"\"\" def __init__ ( self , config : Config ) : self . config : Config = config self . passed : bool = False self . result : Any = None @property def config ( self ) -> Config : return self . _config @config . setter def config ( self , config : Config ) -> None : # It should be possible to check if config is already set # and if it is throw an exception . Might be needed since # child objects rely on the configs uid . self . _config = config @property def passed ( self ) -> bool : return self . _passed @passed . setter def passed ( self , new_value : bool ) -> None : self . _passed = new_value @property def result ( self ) -> Any : return self . _result @result . setter def result ( self , new_value : Any ) -> None : self . _result = new_value def __enter__ ( self ) : try : self . run () except BaseException as ex : self . clean_up () raise ex return self . result def __exit__ ( self , exc_type , exc_val , exc_tb ) : # we could optionally call self . report () on exiting . self . clean_up () @classmethod def from_file ( cls : Type [ T ] , project_root : str = \"./\" , input_file : str = \"./.taskcat.yml\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat config file. Args: project_root (str, optional): The path to the directory with your template and config file. Defaults to \" . / \". input_file (str, optional): The name of the Taskcat confile file. Defaults to \" . / . taskcat . yml \". regions (str, optional): A comma separated list of regions to test in. Defaults to \" ALL \". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa : B950 project_root_path : Path = Path ( project_root ). expanduser (). resolve () input_file_path : Path = project_root_path / input_file # pylint : disable = too - many - arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) config = Config . create ( project_root = project_root_path , project_config_path = input_file_path , args = args # TODO : detect if input file is taskcat config or CloudFormation template ) return cls ( config ) @classmethod def from_dict ( cls : Type [ T ] , input_config : dict , project_root : str = \"./\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat configuration in dictionary form. Args: input_config (dict): A Taskcat configuration in the form of a dict. project_root (str, optional): The path to the directory with your template and config file. Defaults to \" . / \". regions (str, optional): A comma separated list of regions to test in. Defaults to \" ALL \". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa : B950 project_root_path : Path = Path ( project_root ). expanduser (). resolve () # pylint : disable = too - many - arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) sources = [ {\"source\": \"Manual\", \"config\": input_config}, {\"source\": \"CliArgument\", \"config\": args}, ] config = Config ( uid = uuid . uuid4 (), project_root = project_root_path , sources = sources ) return cls ( config ) Ancestors (in MRO) taskcat.testing._abstract_test.Test abc.ABC Descendants taskcat.testing._cfn_test.CFNTest taskcat.testing._lint_test.LintTest taskcat.testing._unit_test.UnitTest Static methods from_dict def from_dict ( input_config : dict , project_root : str = './' , regions : str = 'ALL' , enable_sig_v2 : bool = False ) -> ~ T Creates a Test from a Taskcat configuration in dictionary form. Parameters: Name Type Description Default input_config dict A Taskcat configuration in the form of a dict. None project_root str The path to the directory with your template and config file. Defaults to \"./\". \"./\" regions str A comma separated list of regions to test in. Defaults to \"ALL\". \"ALL\" enable_sig_v2 bool Enable legacy sigv2 requests for auto-created buckets. Defaults to False. False Returns: Type Description T Returns a Test instance. View Source @classmethod def from_dict ( cls : Type [ T ] , input_config : dict , project_root : str = \"./\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat configuration in dictionary form. Args: input_config (dict): A Taskcat configuration in the form of a dict. project_root (str, optional): The path to the directory with your template and config file. Defaults to \" . / \". regions (str, optional): A comma separated list of regions to test in. Defaults to \" ALL \". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa : B950 project_root_path : Path = Path ( project_root ). expanduser (). resolve () # pylint : disable = too - many - arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) sources = [ {\"source\": \"Manual\", \"config\": input_config}, {\"source\": \"CliArgument\", \"config\": args}, ] config = Config ( uid = uuid . uuid4 (), project_root = project_root_path , sources = sources ) return cls ( config ) from_file def from_file ( project_root : str = './' , input_file : str = './.taskcat.yml' , regions : str = 'ALL' , enable_sig_v2 : bool = False ) -> ~ T Creates a Test from a Taskcat config file. Parameters: Name Type Description Default project_root str The path to the directory with your template and config file. Defaults to \"./\". \"./\" input_file str The name of the Taskcat confile file. Defaults to \"./.taskcat.yml\". \"./.taskcat.yml\" regions str A comma separated list of regions to test in. Defaults to \"ALL\". \"ALL\" enable_sig_v2 bool Enable legacy sigv2 requests for auto-created buckets. Defaults to False. False Returns: Type Description T Returns a Test instance. View Source @classmethod def from_file ( cls : Type [ T ] , project_root : str = \"./\" , input_file : str = \"./.taskcat.yml\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat config file. Args: project_root (str, optional): The path to the directory with your template and config file. Defaults to \" . / \". input_file (str, optional): The name of the Taskcat confile file. Defaults to \" . / . taskcat . yml \". regions (str, optional): A comma separated list of regions to test in. Defaults to \" ALL \". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa : B950 project_root_path : Path = Path ( project_root ). expanduser (). resolve () input_file_path : Path = project_root_path / input_file # pylint : disable = too - many - arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) config = Config . create ( project_root = project_root_path , project_config_path = input_file_path , args = args # TODO : detect if input file is taskcat config or CloudFormation template ) return cls ( config ) Instance variables config passed result Methods clean_up def clean_up ( self ) -> None Clean up after the Test. View Source @abstractmethod def clean_up ( self ) -> None : \"\"\"Clean up after the Test.\"\"\" run def run ( self ) -> None Run the Test. View Source @abstractmethod def run ( self ) -> None : \"\"\"Run the Test.\"\"\"","title":"Base Test"},{"location":"reference/taskcat/testing/base_test/#module-taskcattestingbase_test","text":"None None View Source # pylint: disable=line-too-long import uuid from pathlib import Path from typing import Any , Dict , Type , TypeVar from taskcat._cli_core import GLOBAL_ARGS from taskcat._config import Config from ._abstract_test import Test T = TypeVar ( \"T\" , bound = \"BaseTest\" ) # pylint: disable=invalid-name class BaseTest ( Test ): \"\"\"A Generic Test Class that implements the passed and uid properties. Any subclass will still need to implement the the run and clean_up methods. \"\"\" def __init__ ( self , config : Config ): self . config : Config = config self . passed : bool = False self . result : Any = None @property def config ( self ) -> Config : return self . _config @config . setter def config ( self , config : Config ) -> None : # It should be possible to check if config is already set # and if it is throw an exception. Might be needed since # child objects rely on the configs uid. self . _config = config @property def passed ( self ) -> bool : return self . _passed @passed . setter def passed ( self , new_value : bool ) -> None : self . _passed = new_value @property def result ( self ) -> Any : return self . _result @result . setter def result ( self , new_value : Any ) -> None : self . _result = new_value def __enter__ ( self ): try : self . run () except BaseException as ex : self . clean_up () raise ex return self . result def __exit__ ( self , exc_type , exc_val , exc_tb ): # we could optionally call self.report() on exiting. self . clean_up () @classmethod def from_file ( cls : Type [ T ], project_root : str = \"./\" , input_file : str = \"./.taskcat.yml\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat config file. Args: project_root (str, optional): The path to the directory with your template and config file. Defaults to \"./\". input_file (str, optional): The name of the Taskcat confile file. Defaults to \"./.taskcat.yml\". regions (str, optional): A comma separated list of regions to test in. Defaults to \"ALL\". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa: B950 project_root_path : Path = Path ( project_root ) . expanduser () . resolve () input_file_path : Path = project_root_path / input_file # pylint: disable=too-many-arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) config = Config . create ( project_root = project_root_path , project_config_path = input_file_path , args = args # TODO: detect if input file is taskcat config or CloudFormation template ) return cls ( config ) @classmethod def from_dict ( cls : Type [ T ], input_config : dict , project_root : str = \"./\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat configuration in dictionary form. Args: input_config (dict): A Taskcat configuration in the form of a dict. project_root (str, optional): The path to the directory with your template and config file. Defaults to \"./\". regions (str, optional): A comma separated list of regions to test in. Defaults to \"ALL\". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa: B950 project_root_path : Path = Path ( project_root ) . expanduser () . resolve () # pylint: disable=too-many-arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) sources = [ { \"source\" : \"Manual\" , \"config\" : input_config }, { \"source\" : \"CliArgument\" , \"config\" : args }, ] config = Config ( uid = uuid . uuid4 (), project_root = project_root_path , sources = sources ) return cls ( config ) def _build_args ( enable_sig_v2 , regions , default_profile ): args : Dict [ str , Any ] = {} if enable_sig_v2 : args [ \"project\" ] = { \"s3_enable_sig_v2\" : enable_sig_v2 } if regions != \"ALL\" : if \"project\" not in args : args [ \"project\" ] = {} args [ \"project\" ][ \"regions\" ] = regions . split ( \",\" ) if default_profile : _auth_dict = { \"default\" : default_profile } if not args . get ( \"project\" ): args [ \"project\" ] = { \"auth\" : _auth_dict } else : args [ \"project\" ][ \"auth\" ] = _auth_dict return args","title":"Module taskcat.testing.base_test"},{"location":"reference/taskcat/testing/base_test/#variables","text":"T","title":"Variables"},{"location":"reference/taskcat/testing/base_test/#classes","text":"","title":"Classes"},{"location":"reference/taskcat/testing/base_test/#basetest","text":"class BaseTest ( config : taskcat . _config . Config ) View Source class BaseTest ( Test ) : \"\"\"A Generic Test Class that implements the passed and uid properties. Any subclass will still need to implement the the run and clean_up methods. \"\"\" def __init__ ( self , config : Config ) : self . config : Config = config self . passed : bool = False self . result : Any = None @property def config ( self ) -> Config : return self . _config @config . setter def config ( self , config : Config ) -> None : # It should be possible to check if config is already set # and if it is throw an exception . Might be needed since # child objects rely on the configs uid . self . _config = config @property def passed ( self ) -> bool : return self . _passed @passed . setter def passed ( self , new_value : bool ) -> None : self . _passed = new_value @property def result ( self ) -> Any : return self . _result @result . setter def result ( self , new_value : Any ) -> None : self . _result = new_value def __enter__ ( self ) : try : self . run () except BaseException as ex : self . clean_up () raise ex return self . result def __exit__ ( self , exc_type , exc_val , exc_tb ) : # we could optionally call self . report () on exiting . self . clean_up () @classmethod def from_file ( cls : Type [ T ] , project_root : str = \"./\" , input_file : str = \"./.taskcat.yml\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat config file. Args: project_root (str, optional): The path to the directory with your template and config file. Defaults to \" . / \". input_file (str, optional): The name of the Taskcat confile file. Defaults to \" . / . taskcat . yml \". regions (str, optional): A comma separated list of regions to test in. Defaults to \" ALL \". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa : B950 project_root_path : Path = Path ( project_root ). expanduser (). resolve () input_file_path : Path = project_root_path / input_file # pylint : disable = too - many - arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) config = Config . create ( project_root = project_root_path , project_config_path = input_file_path , args = args # TODO : detect if input file is taskcat config or CloudFormation template ) return cls ( config ) @classmethod def from_dict ( cls : Type [ T ] , input_config : dict , project_root : str = \"./\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat configuration in dictionary form. Args: input_config (dict): A Taskcat configuration in the form of a dict. project_root (str, optional): The path to the directory with your template and config file. Defaults to \" . / \". regions (str, optional): A comma separated list of regions to test in. Defaults to \" ALL \". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa : B950 project_root_path : Path = Path ( project_root ). expanduser (). resolve () # pylint : disable = too - many - arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) sources = [ {\"source\": \"Manual\", \"config\": input_config}, {\"source\": \"CliArgument\", \"config\": args}, ] config = Config ( uid = uuid . uuid4 (), project_root = project_root_path , sources = sources ) return cls ( config )","title":"BaseTest"},{"location":"reference/taskcat/testing/base_test/#ancestors-in-mro","text":"taskcat.testing._abstract_test.Test abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/taskcat/testing/base_test/#descendants","text":"taskcat.testing._cfn_test.CFNTest taskcat.testing._lint_test.LintTest taskcat.testing._unit_test.UnitTest","title":"Descendants"},{"location":"reference/taskcat/testing/base_test/#static-methods","text":"","title":"Static methods"},{"location":"reference/taskcat/testing/base_test/#from_dict","text":"def from_dict ( input_config : dict , project_root : str = './' , regions : str = 'ALL' , enable_sig_v2 : bool = False ) -> ~ T Creates a Test from a Taskcat configuration in dictionary form. Parameters: Name Type Description Default input_config dict A Taskcat configuration in the form of a dict. None project_root str The path to the directory with your template and config file. Defaults to \"./\". \"./\" regions str A comma separated list of regions to test in. Defaults to \"ALL\". \"ALL\" enable_sig_v2 bool Enable legacy sigv2 requests for auto-created buckets. Defaults to False. False Returns: Type Description T Returns a Test instance. View Source @classmethod def from_dict ( cls : Type [ T ] , input_config : dict , project_root : str = \"./\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat configuration in dictionary form. Args: input_config (dict): A Taskcat configuration in the form of a dict. project_root (str, optional): The path to the directory with your template and config file. Defaults to \" . / \". regions (str, optional): A comma separated list of regions to test in. Defaults to \" ALL \". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa : B950 project_root_path : Path = Path ( project_root ). expanduser (). resolve () # pylint : disable = too - many - arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) sources = [ {\"source\": \"Manual\", \"config\": input_config}, {\"source\": \"CliArgument\", \"config\": args}, ] config = Config ( uid = uuid . uuid4 (), project_root = project_root_path , sources = sources ) return cls ( config )","title":"from_dict"},{"location":"reference/taskcat/testing/base_test/#from_file","text":"def from_file ( project_root : str = './' , input_file : str = './.taskcat.yml' , regions : str = 'ALL' , enable_sig_v2 : bool = False ) -> ~ T Creates a Test from a Taskcat config file. Parameters: Name Type Description Default project_root str The path to the directory with your template and config file. Defaults to \"./\". \"./\" input_file str The name of the Taskcat confile file. Defaults to \"./.taskcat.yml\". \"./.taskcat.yml\" regions str A comma separated list of regions to test in. Defaults to \"ALL\". \"ALL\" enable_sig_v2 bool Enable legacy sigv2 requests for auto-created buckets. Defaults to False. False Returns: Type Description T Returns a Test instance. View Source @classmethod def from_file ( cls : Type [ T ] , project_root : str = \"./\" , input_file : str = \"./.taskcat.yml\" , regions : str = \"ALL\" , enable_sig_v2 : bool = False , ) -> T : \"\"\"Creates a Test from a Taskcat config file. Args: project_root (str, optional): The path to the directory with your template and config file. Defaults to \" . / \". input_file (str, optional): The name of the Taskcat confile file. Defaults to \" . / . taskcat . yml \". regions (str, optional): A comma separated list of regions to test in. Defaults to \" ALL \". enable_sig_v2 (bool, optional): Enable legacy sigv2 requests for auto-created buckets. Defaults to False. Returns: T: Returns a Test instance. \"\"\" # noqa : B950 project_root_path : Path = Path ( project_root ). expanduser (). resolve () input_file_path : Path = project_root_path / input_file # pylint : disable = too - many - arguments args = _build_args ( enable_sig_v2 , regions , GLOBAL_ARGS . profile ) config = Config . create ( project_root = project_root_path , project_config_path = input_file_path , args = args # TODO : detect if input file is taskcat config or CloudFormation template ) return cls ( config )","title":"from_file"},{"location":"reference/taskcat/testing/base_test/#instance-variables","text":"config passed result","title":"Instance variables"},{"location":"reference/taskcat/testing/base_test/#methods","text":"","title":"Methods"},{"location":"reference/taskcat/testing/base_test/#clean_up","text":"def clean_up ( self ) -> None Clean up after the Test. View Source @abstractmethod def clean_up ( self ) -> None : \"\"\"Clean up after the Test.\"\"\"","title":"clean_up"},{"location":"reference/taskcat/testing/base_test/#run","text":"def run ( self ) -> None Run the Test. View Source @abstractmethod def run ( self ) -> None : \"\"\"Run the Test.\"\"\"","title":"run"}]}